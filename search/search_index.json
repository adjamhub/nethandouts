{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Corso di Reti La teoria delle reti <p>La Suite Internet e le organizzazioni che la gestiscono.</p> Reti <p>Protocolli di rete, indirizzamento IPv4, IPv6, subnetting</p> Routing <p>Selezione del percorso di rete</p> Trasporto <p>Individuazione del mittente e del destinatario della comunicazione</p> HTTP <p>Siti web, servizi web, richieste e risposte HTTP</p> DNS <p>Risoluzione dei nomi di dominio</p> DHCP <p>Configurazione dinamica degli host di rete</p> MAIL <p>Protocolli per la posta elettronica</p>"},{"location":"DHCP/DHCP/","title":"Protocollo DHCP","text":"<p>DHCP (Dynamic Host Configuration Protocol) \u00e8 un protocollo del livello superiore  della suite di protocolli Internet,  utilizzato per l\u2019assegnazione automatica degli indirizzi IP che permette una  configurazione dinamica di tutte le impostazioni di rete per le stazioni che lo utilizzano.</p> <p>Il protocollo \u00e8 basato sul paradigma client/server e utilizza il protocollo UDP  del livello di trasporto con il server in ascolto sulla porta 67 e il client in comunicazione sulla porta 68: se gi\u00e0 conoscete il livello di trasporto,  questi numeri di porta ci dicono che sia client che server DHCP devono  essere eseguiti con privilegi amministrativi.</p>"},{"location":"DHCP/DHCP/#configurazione-di-rete-informazioni-necessarie","title":"Configurazione di rete: informazioni necessarie.","text":"<p>Dico una banalit\u00e0: per connettersi ad una rete un dispositivo ha bisogno di  un indirizzo IP! Vero! Necessario, ma non sufficiente!</p> <p>Le informazioni necessarie ad un dispositivo che vuole connettersi alla rete sono le seguenti:</p> <ol> <li> <p>Indirizzo IP</p> <p>Questa informazione serve ad identificare un dispositivo all'interno di una rete.  Ogni dispositivo su una rete chiusa ha un indirizzo IP diverso.  Quindi, ad esempio, ogni dispositivo che si connette a internet ha un diverso indirizzo IP.</p> </li> <li> <p>Subnet Mask</p> <p>Questo parametro serve per capire a quale \u201csotto-rete\u201d appartiene un dispositivo.  Una sotto-rete \u00e8 un gruppo locale di dispositivi collegati allo stesso router.  Affronteremo meglio questo concetto studiando il protocollo IP.</p> </li> <li> <p>Default Gateway</p> <p>Questo parametro \u00e8 quello che serve al dispositivo per connettersi a tutti i dispositivi che non appartengono alla sua sotto-rete.  Senza questa informazione \u00e8 possibile solo una connessione locale fra i dispositivi della stessa sotto-rete.</p> </li> <li> <p>Elenco dei server DNS utilizzabili</p> <p>Tipicamente vengono forniti gli indirizzi di 2 server DNS che verranno utilizzati in sequenza.  Senza questa informazione la rete funziona, ma i nomi di dominio non possono essere risolti,  rendendo la navigazione molto complicata (o per certi versi impossibile).</p> </li> </ol> <p>Ora... in quale modo un dispositivo pu\u00f2 ottenere queste informazioni? Ci sono 2 modalit\u00e0:</p> <ol> <li>tramite una configurazione statica, con l\u2019utente che inserisce manualmente queste informazioni nel sistema operativo.</li> <li>Tramite una configurazione dinamica, con il sistema operativo configurato per ottenere le informazioni tramite DHCP</li> </ol>"},{"location":"DHCP/DHCP/#logica-di-funzionamento","title":"Logica di funzionamento","text":"<p>Il client DHCP, solitamente appena il dispositivo viene acceso, fa una richiesta al server per ottenere un indirizzo IP e  tutte le informazioni necessarie alla configurazione della rete.</p> <p>Ma... il dispositivo non ha ancora un indirizzo IP, come fa a comunicare? E anche se lo avesse,  come fa a sapere dove si trova il server DHCP a cui indirizzare la richiesta?</p> <p>La risposta a tutte queste domande \u00e8 una sola: il client DHCP utilizza per la comunicazione il broadcast, in particolare comunicando  tramite l\u2019indirizzo speciale <code>255.255.255.255</code>: il broadcast della rete corrente!.</p> <p>Nel primo messaggio del client esso scrive una richiesta di questo tipo:</p> <p>Ci sarebbe un indirizzo IP per la scheda XX:XX:YY:YY:ZZ:ZZ ?</p> <p>Il numero che esso indica si chiama indirizzo MAC ed \u00e8 un identificatore univoco della scheda di rete: tutte le schede di rete prodotte  in tutto il mondo in tutta la storia del pianeta Terra sono state identificate con un indirizzo MAC diverso. Ne parleremo studiando il livello di rete.</p> <p>Tutti ricevono la richiesta del client che ha bisogno di informazioni (ovviamente! \u00c8 stata inviata in broadcast...)  ma solo il dispositivo con il server DHCP la prende in considerazione e produce una risposta di questo tipo:</p> <p>L\u2019indirizzo IP per la scheda XX:XX:YY:YY:ZZ:ZZ \u00e8 10.11.12.13. Allegate le informazioni necessarie per la configurazione di rete.</p> <p>La risposta del server deve essere rinviata ancora in broadcast, infatti il dispositivo destinatario non ha ancora un indirizzo:  tutti riceveranno anche questo messaggio, ma l\u2019unico autorizzato ad utilizzare quell\u2019IP sar\u00e0 quello con la scheda indicata.</p>"},{"location":"DHCP/DHCP/#server-dhcp","title":"Server DHCP","text":"<p>Abbiamo capito in quale modo un client pu\u00f2 richiedere ad un server DHCP un indirizzo IP e le informazioni per la configurazione della rete.  Ma quanti IP ha da assegnare un server DHCP?</p> <p>Ogni server DHCP viene configurato con un intervallo di indirizzi, definito scope, che pu\u00f2 utilizzare per le assegnazioni.</p> <p>Chiaramente il server non pu\u00f2 usufruire del suo stesso servizio e quindi la configurazione di rete di un dispositivo in cui si eseguir\u00e0 un server DHCP deve essere statica.</p> <p>Il server DHCP non regala gli IP ai client che li richiedono ma li fornisce in affitto (in lease) per un tempo di affitto prestabilito (lease time).</p> <p>Al termine del lease, il client deve liberare l\u2019IP che gli \u00e8 stato affidato, ma ha ovviamente la possibilit\u00e0 di richiedere un nuovo lease al server.</p> <p>Ogni volta che il server fornisce un lease ad un client esso si costruisce una tabella che contiene per ogni riga:</p> <ul> <li>l\u2019indirizzo IP assegnato</li> <li>l\u2019indirizzo MAC che ha fatto la richiesta</li> <li>la data e l\u2019ora di scadenza del lease</li> </ul> <p>In questo modo, oltre ad avere sempre il controllo sulla situazione delle prenotazioni degli indirizzi, ha anche la possibilit\u00e0 di riassegnare lo stesso IP dopo la scadenza del lease.</p> <p> </p>"},{"location":"DHCP/lab_AccessPoint_DIY/","title":"Access Point Fai da te","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: Raspberry, terminale linux</p> <p>Argomenti trattati: DHCP, DNS, Indirizzamento IP</p> <p>L'idea \u00e8 quella di implementare un Access Point WIFI analogo a quelli che si hanno a casa per la connessione, con server DHCP e server DNS configurati manualmente.</p> <p>Prima di andare avanti, ricordiamoci di aggiornare il sistema, ripulire e riavviare.</p> <pre><code>$ sudo apt update\n$ sudo apt upgrade\n$ sudo apt autoremove\n$ sudo reboot\n</code></pre>"},{"location":"DHCP/lab_AccessPoint_DIY/#scegliere-un-piano-di-indirizzamento","title":"Scegliere un piano di indirizzamento","text":"<p>Da quello che abbiamo studiato sappiamo che ogni scheda di rete ha il suo indirizzo IP. Nel nostro Raspberry ci sono 2 schede di rete:</p> <ol> <li>la schede di rete cablata, che si chiama <code>eth0</code></li> <li>la scheda di rete wifi, che si chiama <code>wlan0</code></li> </ol> <p>La scheda di rete cablata dovrebbe essere collegata alla rete della scuola, quindi ha gi\u00e0 un indirizzo IP fornito dai server DHCP della scuola. La scheda di rete wifi non dovrebbe essere collegata a nulla e quindi non avere alcun indirizzo.</p> <p>Per verificare i nomi delle schede di rete e l'indirizzamento attuale del nostro Raspberry procediamo da terminale con il comando <code>ifconfig</code>  (Valido anche da terminale Mac e analogo del comando ipconfig di Windows).</p> <p>Si dovrebbe vedere qualcosa di simile a questo:</p> <p></p> <p>L'indirizzo IP della scheda WIFI dovr\u00e0 essere statico e scelto da noi. Per il mio esempio e come riferimento in quello che scriver\u00f2 dopo, io scelgo l'indirizzo 192.168.0.1/24.</p> <p>A questo punto, immaginando che collegher\u00f2 il server DHCP all'interfaccia <code>wlan0</code> dovr\u00f2 scegliere uno scope e identificare tutte le informazioni da passare ai client DHCP.</p> <p>Io ho scelto le seguenti:</p> <ol> <li>scope: 192.168.0.11-30 con TTL di 1 ora</li> <li>gateway sar\u00e0 ovviamente l'IP del Raspberry: 192.168.0.1</li> <li>DNS sar\u00e0 ancora una volta il Raspberry.</li> </ol> <p>Ultima cosa, poich\u00e9 si va ad implementare una rete wifi con password, bisogna scegliere il nome della rete Wifi (che si definisce SSID) e la chiave di accesso (la <code>password</code> del wifi).</p> <p>Tenendo bene a mente (no, meglio se segnate su un foglio) le precedenti informazioni, possiamo procedere nell'implementazione del router/AccessPoint con Raspberry.</p>"},{"location":"DHCP/lab_AccessPoint_DIY/#installare-e-configurare-dnsmasq","title":"Installare e configurare dnsmasq","text":"<p>L'installazione \u00e8 facile:</p> <pre><code>$ sudo apt install dnsmasq\n</code></pre> <p>Il file di configurare da modificare \u00e8 il seguente</p> <pre><code>$ sudo nano /etc/dnsmasq.conf\n</code></pre> <p>Va impostato in questo modo, trovando le sezioni opportune:</p> <pre><code># to activate dhcp server on 1 interface\ninterface=wlan0\nbind-interfaces \n\n# scope\ndhcp-range=192.168.0.11,192.168.0.30,255.255.255.0,1h\n\n# options\ndhcp-option=option:router,192.168.0.1\n\n# dns configuration\nlisten-address=192.168.0.1\nserver=1.1.1.1\ndomain-needed\nbogus-priv\n</code></pre>"},{"location":"DHCP/lab_AccessPoint_DIY/#installare-hostapd","title":"Installare hostapd","text":"<p>Qui l'installazione \u00e8 pi\u00f9 complicata :)</p> <pre><code>$ sudo apt install hostapd\n$ sudo systemctl unmask hostapd\n$ sudo systemctl stop hostapd\n</code></pre> <p>Il file di configurazione va inserito nel percorso <code>/etc/hostapd/hostapd.conf</code>, quindi con il comando:</p> <pre><code>$ sudo nano /etc/hostapd/hostapd.conf\n</code></pre> <p>Va copiato dentro pari pari il seguente codice, modificando opportunamente l'SSID scelto e la chiave di accesso:</p> <pre><code># set operation mode\ninterface=wlan0\ndriver=nl80211\nhw_mode=g\ncountry_code=IT\nchannel=6\n\n## Key management algorithms ##\nwpa_key_mgmt=WPA-PSK\nwpa=2\n\n## Set cipher suites (encryption algorithms) ##\n## TKIP = Temporal Key Integrity Protocol\n## CCMP = AES in Counter mode with CBC-MAC\nwpa_pairwise=TKIP\nrsn_pairwise=CCMP\n\n## Shared Key Authentication ##\nauth_algs=1\n\n## Accept all MAC address ###\nmacaddr_acl=0\n\n# SSID &amp; passphrase\nssid=IL_NOME_DELLA_RETE_WIFI\nwpa_passphrase=LA_PASSWORD_DEL_WIFI\n</code></pre> <p>Fai in modo che il file di configurazione venga caricato dal demone hostapd: apri <code>/etc/default/hostapd</code> e modificalo come indicato</p> <pre><code>$ sudo nano /etc/default/hostapd\n</code></pre> <p>Va modificata un'unica riga, in corrispondenza della voce DAEMON_CONF che va decommentata e riempita come indicato.</p> <pre><code>DAEMON_CONF=\"/etc/hostapd/hostapd.conf\"\n</code></pre> <p>Ok, siamo pronti!</p>"},{"location":"DHCP/lab_AccessPoint_DIY/#ultime-impostazioni","title":"Ultime impostazioni","text":"<p>Le ultime operazioni da fare servono per far funzionare il Raspberry come un router e permettergli dunque di condividere la sua connettivit\u00e0 con tutti quelli connessi al suo Wifi tramite hostapd. Sono operazioni standard che vanno eseguite una ad una nella riga di comando.</p> <p>Le divido blocco per blocco per evidenziare i vari passaggi.</p> <p>Impostazione IP statico rete Wifi</p> <pre><code>$ sudo ip link set wlan0 up\n$ sudo ip addr add 192.168.0.1/24 dev wlan0\n</code></pre> <p>Abilitazione traffico di rete attraverso il Raspberry</p> <pre><code>$ sudo sysctl -w net.ipv4.ip_forward=1\n$ sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\n$ sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT\n$ sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT\n</code></pre> <p>Ultimo, se non ci sono messaggi di errori precedenti, avviare hostapd e dnsmasq.</p> <pre><code>$ sudo systemctl start hostapd\n$ sudo systemctl start dnsmasq\n</code></pre> <p>Ecco fatto, dovrebbe funzionare tutto!</p> <p>Prendete il vostro telefono e provate a connettervi alla rete Wifi del Raspberry e a navigare!</p> <p> </p>"},{"location":"DHCP/lab_DHCP_server/","title":"DHCP Server","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: Linux: terminale</p> <p>Argomenti trattati: DHCP, DNS, Indirizzamento IP</p> <p>In questo capitolo andremo ad installare un server DHCP su un dispositivo con OS Linux. Questo dispositivo monta una versione di Linux con package manager apt, quindi potrebbe essere un RaspberryPi oppure una installazione di Ubuntu Server.</p> <p>Se avete studiato il protocollo DHCP, sapete che per far funzionare un server DHCP c'\u00e8 bisogno di un dispositivo con un indirizzo statico. Il capitolo sul Networking spiega come ottenere questo risultato.</p> <p>Il server DHCP che andiamo ad installare si chiama KEA (https://www.isc.org/kea/). KEA \u00e8 un server DHCP open source sviluppato dall'Internet Systems Consortium come (futuro) sostituto dello storico ISC DHCP SERVER. Se volete saperne di pi\u00f9... leggete dal sito che ho linkato o guardate Wikipedia </p> <p>Per installare il server DHCP KEA, relativo al protocollo IPv4 sul nostro OS, dopo un aggiornamento generale dei pacchetti installati, ci baster\u00e0 fare un semplice:</p> <pre><code>$ sudo apt install kea-dhcp4-server\n</code></pre> <p>Il file di configurazione dello stesso si trova nella directory /etc/kea. Noi dobbiamo modificare il file kea-dhcp4.conf. Poich\u00e9 in esso trovate una marea di commenti e spiegazioni a tutti i parametri possibili e immaginabili, ho provato a scriverne una versione light, mettendo in evidenza SOLO i parametri importanti o indispensabili</p> <pre><code>// Va modificato in questi 3 punti (leggilo TUTTO per trovarli):\n// - cambia il nome della tua interfaccia di rete in cui vuoi attivare il server DHCP\n// - cambia lo SCOPE degli indirizzi che vuoi servire tramite DHCP\n// - cambia le impostazioni di rete, come GW e DNS da inviare ai client\n//\n// Salva il file modificato su /etc/kea/kea-dhcp4.conf (richiede privilegi amministrativi per farlo)\n// In bocca al lupo... e buona lettura!\n\n{\n\n\"Dhcp4\": {\n    \"interfaces-config\": {\n        \"interfaces\": [ \"eth0\" ]\n\n        // USEFUL FOR RELAY\n        // \"dhcp-socket-type\": \"udp\"\n    },\n\n    // NON TOCCARE ;)\n    \"control-socket\": {\n        \"socket-type\": \"unix\",\n        \"socket-name\": \"/tmp/kea4-ctrl-socket\"\n    },\n\n    // KEA pu\u00f2 utilizzare diversi database per mantenere i propri lease\n    // - \"memfile\" : un semplice file CSV salvato da qualche parte\n    // - \"mysql\", \"postgres\", \"cassandra\": database esterni (complicato)\n    // Per saperne di pi\u00f9, cerca su internet \"KEA LEASE STORAGE\"\n    \"lease-database\": {\n        \"type\": \"memfile\",\n        \"lfc-interval\": 3600\n    },\n\n\n    // PARAMETRI AVANZATI PER IL LEASE\n    // meglio non toccare anche qui...\n    \"expired-leases-processing\": {\n        \"reclaim-timer-wait-time\": 10,\n        \"flush-reclaimed-timer-wait-time\": 25,\n        \"hold-reclaimed-time\": 3600,\n        \"max-reclaim-leases\": 100,\n        \"max-reclaim-time\": 250,\n        \"unwarned-reclaim-cycles\": 5\n    },\n\n\n    // LEASE TIMER(s) \n    \"renew-timer\": 900,\n    \"rebind-timer\": 1800,\n    \"valid-lifetime\": 3600,\n\n\n    // PARAMETRI ADDIZIONALI\n    \"option-data\": [\n\n        // DNS\n        {\n            \"name\": \"domain-name-servers\",\n            \"data\": \"192.0.2.1, 192.0.2.2\"\n        },\n\n\n        // NOME DI DOMINIO DELLA RETE\n        // (\"completa\" il nome di un pc, come un \"cognome\". \n        // Il PC chiamato PC1, nella rete sar\u00e0 conosciuto come PC1.adjam.org)\n        {\n            \"name\": \"domain-name\",\n            \"data\": \"adjam.org\"\n        },\n\n\n        // DOMINIO DI RICERCA\n        // se questo parametro vale \"pippo.com\" e tu cerchi tramite DNS un nome\n        // semplice, tipo \"ciccio\", prova a risolvere sia \"ciccio\" che \"ciccio.pippo.com\"\n        {\n            \"name\": \"domain-search\",\n            \"data\": \"mydomain.example.com, example.com\"\n        },\n\n\n        // Giuro... non ho mai capito. Lasciamoli stare...\n        {\n            \"name\": \"boot-file-name\",\n            \"data\": \"EST5EDT4,M3.2.0/02:00,M11.1.0/02:00\"\n        },\n\n        {\n            \"name\": \"default-ip-ttl\",\n            \"data\": \"0xf0\"\n        }\n\n    ],\n\n\n    // LA SOTTORETE CHE CONTIENE LO SCOPE \n    // (per ogni sottorete ci pu\u00f2 essere un solo scope)\n    \"subnet4\": [\n        {\n            // LA SUBNET INTERA\n            \"subnet\": \"192.0.2.0/24\",\n\n\n            // LO \"SCOPE\" degli indirizzi assegnabili tramite DHCP per la subnet precedente\n            \"pools\": [ { \"pool\": \"192.0.2.1 - 192.0.2.200\" } ],\n\n\n            // IL GATEWAY (\"router\" nella terminologia DHCP)\n            \"option-data\": [\n                {\n                    \"name\": \"routers\",\n                    \"data\": \"192.0.2.1\"\n                }\n            ],\n\n\n            // PRENOTAZIONI\n            // indirizzi FUORI dallo SCOPE assegnati a precisi client per motivi...\n            // (se non volete usare le prenotazioni, potete cancellare il segmento fino al segno)\n            \"reservations\": [\n\n\n                // PRENOTAZIONE semplice CON MAC/IP\n                {\n                    \"hw-address\": \"1a:1b:1c:1d:1e:1f\",\n                    \"ip-address\": \"192.0.2.201\"\n                },\n\n                // PRENOTAZIONE con parametri alterati. \n                // Solo questo client avr\u00e0 una configurazione dedicata\n                {\n                    \"hw-address\": \"1a:1b:1c:1d:1e:12\",\n                    \"ip-address\": \"192.0.2.203\",\n                    \"option-data\": [ {\n                        \"name\": \"domain-name-servers\",\n                        \"data\": \"10.1.1.202, 10.1.1.203\"\n                    } ]\n                },\n\n            ]\n            // FINE PRENOTAZIONI\n        }\n    ],\n\n\n// Logging configuration.\n// Direi che va IGNORATA e LASCIATA cos\u00ec com'\u00e8...\n    \"loggers\": [\n    {\n        \"name\": \"kea-dhcp4\",\n        \"output_options\": [\n            {\n                // IL FILE DOVE POTRETE SFROGIARE I LEASE...\n                \"output\": \"/var/log/kea-dhcp4.log\"\n            }\n        ],\n\n        // Pu\u00f2 valere: FATAL, ERROR, WARN, INFO, DEBUG\n        // Ogni valore comprende TUTTI i precedenti. Lasciatelo a INFO\n        // E bravi per essere arrivati a leggere fino a qui!\n        \"severity\": \"INFO\",\n\n        // Un numero da 0 (poche info) a 99 (un botto di info)\n        \"debuglevel\": 0\n    }\n  ]\n}\n}\n</code></pre> <p>Fatto quanto richiesto e salvato il file, attiviamo (o riattiviamo) il servizio kea-dhcp4.</p> <pre><code>$ sudo systemctl (re)start kea-dhcp4\n</code></pre> <p>Da questo in momento in poi, se non ci sono errori, il servizio DHCP \u00e8 attivo </p> <p> </p>"},{"location":"DNS/DNS/","title":"Il protocollo DNS","text":"<p>Domain Name System (spesso indicato con DNS) \u00e8 un protocollo del livello superiore della Suite Internet utilizzato per la risoluzione di nomi di host in indirizzi IP e viceversa.</p> <p>I documenti di riferimento relativi sono storicamente RFC 1034 (Nomi di Dominio) e  RFC 1035 (Implementazione DNS).  Il protocollo prevede una implementazione basata sul paradigma client-server e Il suo servizio pu\u00f2 utilizzare sia TCP che UDP sulla porta 53. Le implementazioni originali tendono a favorire la scelta di UDP per motivi prestazionali.</p> <p>I nomi DNS, conosciuti anche come nomi di dominio, come ad esempio \u201cgoogle.it\u201d o \u201cfacebook.com\u201d, sono una delle caratteristiche pi\u00f9 visibili della rete Internet: questo ci fa capire quanto questo servizio sia \u201cradicato\u201d all'interno della rete stessa e necessario agli utenti comuni per poterla utilizzare. I nomi di dominio sono l'informazione contenuta nell'host di ogni URL.</p> <p>L\u2019operazione di convertire un nome in un indirizzo viene definita <code>risoluzione DNS (DNS lookup)</code>, mentre quella di convertire un indirizzo IP in nome \u00e8 definita <code>risoluzione inversa (reverse lookup)</code>.</p> <p></p> <p>Come si evince chiaramente dalla figura, la risoluzione diretta e la risoluzione inversa non sono l\u2019una la funzione inversa dell\u2019altra, ma semplicemente 2 funzioni completamente distinte con l\u2019unica caratteristica in comune che, mentre il DNS lookup traduce un nome di dominio in un indirizzo IP, il reserve lookup traduce un indirizzo IP in un nome di host.</p>"},{"location":"DNS/DNS/#nomi-di-dominio","title":"Nomi di dominio","text":"<p>Un nome di dominio \u00e8 costituito da una serie di stringhe separate da punti, ad esempio</p> <p>reti . informatica . org</p> <p>La parte pi\u00f9 importante del nome di dominio \u00e8 quella pi\u00f9 a destra, nominata dominio di primo livello (TLD, Top Level Domain).  Ad esempio sono domini di primo livello \u201corg\u201d, \u201cit\u201d, \u201ccom\u201d e cos\u00ec via.</p> <p>A seguire verso sinistra abbiamo domini di secondo livello, terzo livello, etc...</p> <p>Un dominio di secondo livello \u00e8 costituito da due parti, per esempio \u201cinformatica.org\u201d;  un dominio di terzo livello \u00e8 composto da tre parti e cos\u00ec via.</p> <p>I domini di primo livello servono solo per la categorizzazione e non possono identificare un host, mentre i domini dal secondo livello in poi s\u00ec; quindi i domini di primo livello sono storicamente fissi e scelti da ICANN (https://it.wikipedia.org/wiki/ICANN), la societ\u00e0 che si occupa di gestire il servizio DNS per la rete Internet, mentre quelli di secondo livello sono in vendita per chiunque desideri acquistarne uno. Quando un dominio di secondo livello viene registrato all\u2019assegnatario, questo \u00e8 autorizzato (gratuitamente) a usare tutti i nomi di dominio relativi ai successivi livelli al suo.</p> <p>Ad esempio se un utente (a caso) ha acquistato il dominio \u201cadjam.org\u201d, questo \u00e8 autorizzato gratuitamente a utilizzare tutti i domini successivi relativi, come ad esempio \u201cstudenti.adjam.org\u201d oppure \u201cimmagini.adjam.org\u201d.</p> <p>La registrazione di un dominio di secondo livello vale per un anno solare, trascorso il quale l'utente deve confermare l'acquisto oppure liberare il dominio per un nuovo (eventuale) utente interessato.</p> <p>In realt\u00e0 tutti i domini di primo livello convergono in un unico livello base, definito livello zero oppure root level, identificato dalla stringa vuota \u201c\u201d come se tutti i domini avessero un punto ulteriore:</p> <p>...secondolivello.TLD.(stringavuota, livello zero)</p> <p>Quindi la risoluzione di tutti i siti web parte da quella che viene chiamata DNS root zone, a cui fa riferimento il livello ZERO. Come vedremo, esistono 13 server autoritativi per la root zone, i cosiddetti DNS root servers (http://www.root-servers.org/).</p>"},{"location":"DNS/DNS/#tipi-di-server-dns","title":"Tipi di server DNS","text":"<p>I server DNS sono configurabili per funzionare in varie modalit\u00e0, a seconda del ruolo che devono svolgere nel sistema di risoluzione:</p> <ul> <li> <p>se configurato in modalit\u00e0 \u201cresolver\u201d, il server risponde   alle query dei client (anzi \u00e8 l\u2019unica modalit\u00e0 che interagisce coi   client) interrogando la sua cache locale ed eventualmente rivolgendo   la domanda agli altri tipi di server fino a che non \u00e8 in grado di   rispondere alla domanda. Nel caso di una nuova informazione il server   fa cache della nuova informazione fino a che risulta valido, ovvero   fino alla scadenza del TTL</p> </li> <li> <p>se configurato in modalit\u00e0 \u201cauthoritative\u201d, il server diventa   responsabile della risoluzione di tutti i nomi di dominio di un   particolare TLD. Un server pu\u00f2 essere autoritativo per un solo TLD e   in quel caso diventa \u201cl\u2019autorit\u00e0\u201d per tutti i domini che terminano con   quel TLD: se contiene una informazione bene, altrimenti significa che   quell'informazione non esiste; se altri (server DNS) dicono una cosa   diversa, sbagliano o hanno informazioni non aggiornate.</p> </li> <li> <p>se configurato in modalit\u00e0 \u201croot server\u201d, esso diventa   responsabile di conoscere gli IP di tutti i server autoritativi per   tutti i TLD esistenti. Se un resolver si trova a dover risolvere un   nome di dominio che non ha in cache e non sa chi sia il server   autoritativo per quel TLD, deve chiedere ad un root server.</p> </li> </ul> <p>Esistono 13 root server in tutto il mondo e sono raggiungibili   banalmente perch\u00e9 sono nominati con le lettere da A ad M (le prime 13   lettere).</p> <p>Per informazioni su di essi: https://root-servers.org/</p>"},{"location":"DNS/DNS/#record-dns","title":"Record DNS","text":"<p>Ad un nome DNS possono corrispondere diversi tipi di informazioni. Per questo motivo, esistono diversi tipi di record DNS. Ogni voce del database DNS deve essere caratterizzata da un tipo e da un TTL (Time To Live): un tempo limite oltre il quale l'informazione contenuta nel record DNS viene considerata obsoleta.</p> <p>I principali tipi sono:</p> Record  Descrizione A Da hostname a IPv4 AAAA Da hostname a IPv6 MX Mail Exchange. Hostname per il server di posta CNAME Alias. Punta ad un record A oppure AAAA PTR Serve per la risoluzione inversa. Da IP a Hostname. SRV Hostname per un servizio generico (generalizzazione di MX) NS Dichiara il server DNS autorevole per quel nome di dominio. <p>Esempi di risoluzione DNS</p> <p>Luca naviga su internet e cerca il sito \u201clibero.it\u201d. Il suo browser invocher\u00e0 una risoluzione DNS dell'host \u201clibero.it\u201d, chiedendo un record di tipo A oppure AAAA.</p> <p>Marco vuole inviare una mail a \u201cluca@libero.it\u201d. Il suo client di posta invocher\u00e0 una risoluzione DNS dell'host \u201clibero.it\u201d richiedendo un record di tipo MX.</p> <p>In questo modo allo stesso host (\"libero.it\" nell\u2019esempio) si possono abbinare 2 servizi diversi (web e mail) e questi 2 servizi possono risiedere su host diversi: il servizio web nell\u2019IP contenuto nel record A, il servizio di posta nell\u2019IP indicato nel record MX.</p> <p>Magia del DNS...</p>"},{"location":"DNS/DNS/#come-funziona-la-risoluzione-dns","title":"Come funziona la risoluzione DNS?","text":"<p>La risoluzione DNS \u00e8 un\u2019operazione estremamente comune nell\u2019utilizzo della rete Internet: praticamente ogni operazione di utilizzo della rete (la navigazione sul web, le chat, il download, etc\u2026) inizia con una risoluzione DNS e soprattutto, diventa impossibile se questa fallisce.</p> <p>Per comprendere il funzionamento della risoluzione DNS, faremo un esempio partendo da un generico host denominato \u201cprova.com\u201d che un client (un PC, un tablet, un telefono, un dispositivo qualsiasi\u2026) prova a risolvere.</p> <p>Di sicuro l\u2019operazione inizia con il client che richiede la risoluzione dell\u2019host ad un server di tipo resolver. Se il server ha il record A (o AAAA) in cache, la risposta arriva subito.</p> <p> </p> <p>Nel caso che il server di tipo resolver non abbia il record abbinato all\u2019host \u201cprova.com\u201d, ma conosca l\u2019indirizzo del server autoritativo \u201c.com\u201d, allora richiede la risoluzione a questo, risponde al client e fa cache del risultato, in modo da poter fornire la risposta direttamente in caso di nuova richiesta.</p> <p> </p> <p>Nell\u2019ultimo caso (il pi\u00f9... sfortunato) il server di tipo resolver che ha ricevuto la richiesta per l\u2019host di esempio \u201cprova.com\u201d non ha il record per la risoluzione e non conosce il server autoritativo per il TLD \u201c.com\u201d. La sua unica opzione \u00e8 quella di chiedere prima ad uno dei root server quale \u00e8 il server autoritativo per quella zona. Ovviamente far\u00e0 cache anche di questa informazione in modo che alla prossima richiesta di un sito \u201c.com\u201d sappia gi\u00e0 a chi chiedere informazioni</p> <p> </p> <p>I root server conoscono di certo la risposta, perch\u00e9 altrimenti questa\u2026 non esiste!! L\u2019individuazione di un root server \u00e8 un\u2019operazione semplice come una risoluzione: come abbiamo detto infatti questi hanno dei nomi predefiniti basati sulle prime 13 lettere dell\u2019alfabeto, che seguono il dominio predefinito \u201croot-servers.net\u201d.</p> <p>Il root server A si pu\u00f2 dunque individuare semplicemente risolvendo l\u2019host \u201ca.root-servers.net\u201d, il root server B corrisponde all\u2019host \u201cb.root-servers.net\u201d e cos\u00ec via\u2026</p> <p>I 13 server sono assolutamente paritetici: sincronizzano fra di loro le informazioni, in modo che ognuno sappia le stesse cose di tutti gli altri!</p> <p> </p>"},{"location":"DNS/lab_DNS_clients/","title":"DNS Clients","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: OS, terminale</p> <p>Argomenti trattati: DNS, URL, Indirizzamento IP</p> <p>La funzionalit\u00e0 di risoluzione DNS ai software che ne hanno bisogno (praticamente tutti quelli che si connettono alla rete) viene solita fornita dal Sistema Operativo tramite le API di sistema.</p> <p>Se per\u00f2 si vogliono ottenere risoluzioni DNS da poter consultare e studiare, \u00e8 possibile utilizzare un client DNS testuale. Fra i pochi che esistono la scelta ricade forzatamente su nslookup (name server lookup) che ha il pregio di essere molto semplice (purtroppo a volte a scapito della dovizia di particolari) e di essere disponibile su tutti i sistemi operativi importanti.</p> <p>Il client nslookup pu\u00f2 essere eseguito in due modalit\u00e0:</p> <ol> <li>command line mode</li> <li>interactive mode</li> </ol>"},{"location":"DNS/lab_DNS_clients/#nslookup-command-line-mode","title":"nslookup: command line mode","text":"<p>Questa modalit\u00e0 \u00e8 la pi\u00f9 semplice e scarna. Si digita nslookup HOST e questi ritorna la risoluzione (i record A, AAAA e CNAME presenti) dell'host fornito e termina</p> <pre><code>$ nslookup www.adjam.org\nServer:         172.104.237.57\nAddress:        172.104.237.57#53\n\nNon-authoritative answer:\nName:   www.adjam.org\nAddress: 217.64.195.209\nName:   www.adjam.org\nAddress: 2001:4b78:1001::5701\n</code></pre> <p>Come si vede, in command line mode nslookup restituisce una risposta standard contentente il server che ha fatto la risoluzione (un server non autorevole, come vediamo sotto) e le risoluzioni trovate, evidentemente, in questo caso, un record A e un record AAAA.</p>"},{"location":"DNS/lab_DNS_clients/#nslookup-interactive-mode","title":"nslookup: interactive mode","text":"<p>Per entrare in interactive mode basta digitare nslookup senza parametri od opzioni. In questo modo cambia il prompt (diventa un maggiore, &gt;) e l\u00ec si pu\u00f2 richiedere la risoluzione di qualunque host ci interessi. Quando abbiamo finito, possiamo uscire dalla modalit\u00e0 interattiva digitando exit.</p> <pre><code>$ nslookup\n\n&gt; google.it\nServer:         172.104.237.57\nAddress:        172.104.237.57#53\n\nNon-authoritative answer:\nName:   google.it\nAddress: 172.217.17.67\nName:   google.it\nAddress: 2a00:1450:400e:805::2003\n\n&gt; libero.it\nServer:         172.104.237.57\nAddress:        172.104.237.57#53\n\nNon-authoritative answer:\nName:   libero.it\nAddress: 213.209.17.209\n\n&gt; exit\n\n$\n</code></pre> <p>la modalit\u00e0 interattiva permette inoltre di fornire alcuni parametri ad nskooup per modificare la risoluzione richiesta, specificandola meglio:</p> <p>comando           descrizione</p> <p>host              l'host da risolvere.   server ip         l'ip del server DNS da utilizzare nelle prossime risoluzioni interattive   set type=record   serve per richiedere la risoluzione del tipo di record indicato. Valori possibili per record sono: A, AAAA, CNAME, MX, NS, PTR ...</p> <p>Qua di seguito far\u00f2 2 esempi per vedere come si utilizzano le 2 opzioni non testate: server e set type</p>"},{"location":"DNS/lab_DNS_clients/#esempio-1-cambiare-server-dns","title":"Esempio #1: cambiare server DNS","text":"<p>Voglio specificare ancora una volta che questa opzione \u00e8 disponibile solo in modalit\u00e0 interattiva e che il cambio di server DNS vale solo per le risoluzioni DNS fatte con nslookup in questa modalit\u00e0 interattiva! Il sistema non \u00e8 minimamente interessato da questa modifica e alla chiusura di nslookup neanche esso se ne ricorder\u00e0:</p> <pre><code>$ nslookup\n\n(la prima risoluzione, fatta col server DNS di default)\n&gt; www.liceodavincijesi.edu.it\nServer:         172.104.237.57\nAddress:        172.104.237.57#53\n\nNon-authoritative answer:\nName:   www.liceodavincijesi.edu.it\nAddress: 89.46.109.18\n\n(cambio di server DNS per la risoluzione)\n&gt; server 1.1.1.1\nDefault server: 1.1.1.1\nAddress: 1.1.1.1#53\n\n(la prossima risoluzione viene fatta verso il server 1.1.1.1)\n&gt; gazzetta.it\nServer:         1.1.1.1\nAddress:        1.1.1.1#53\n\nNon-authoritative answer:\nName:   gazzetta.it\nAddress: 40.1\n</code></pre>"},{"location":"DNS/lab_DNS_clients/#esempio-2-risolvere-un-record-mx","title":"Esempio #2: risolvere un record MX","text":"<p>Pu\u00f2 essere utile e interessante risolvere un record MX tramite nslookup. Per farlo dobbiamo impostare il tipo di record da risolvere con set type. Ricordo per\u00f2 che il record MX ci dir\u00e0 praticamente il record A che individua il dispositivo che fornisce il servizio di posta, che dovr\u00e0 dunque poi essere risolto per ottenere l'indirizzo IP.</p> <pre><code>$ nslookup\n\n(chiedo di risolvere record MX)\n&gt; set type=MX\n\n(risolvo libero.it come MX. Il record MX punta il record con host indicato sotto)\n&gt; libero.it\nServer:         172.104.237.57\nAddress:        172.104.237.57#53\n\nNon-authoritative answer:\nlibero.it       mail exchanger = 10 smtp-in.libero.it.\n\n(ritorno a risolvere record A, come di default)\n&gt; set type=A\n\n(risolvo il record A abbinato al record MX)\n&gt; smtp-in.libero.it\nServer:         172.104.237.57\nAddress:        172.104.237.57#53\n\nNon-authoritative answer:\nName:   smtp-in.libero.it\nAddress: 213.209.1.129\n</code></pre>"},{"location":"DNS/lab_DNS_clients/#web-clients","title":"Web clients","text":"<p>Capita spesso di voler utilizzare il DNS non tanto per verificare il funzionamento di un server, ma per verificare l'effettiva risolvibilit\u00e0 di un sito web. In questo caso tornano utili alcuni client DNS implementati direttamente come servizi WEB. Ne cito alcuni, ritrovati rigorosamente nella prima pagina del mio motore di ricerca preferito all'input DNS web clients:</p> <ul> <li> <p>https://toolbox.googleapps.com/apps/dig/</p> <p>Rappresenta la versione web del famoso client testuale dig, sviluppato al server BIND, il server web pi\u00f9 famoso al mondo. Poco da dire e facile da usare. Molto completo nelle risposte (troppo per noi?), ma molto semplice da utilizzare nella sua interfaccia web.</p> </li> <li> <p>https://www.whatsmydns.net/</p> <p>Esso \u00e8 un sito che permette di specificare una stringa di ricerca, un tipo di record ed effettua la stessa ricerca su una serie di almeno 20 server DNS sparsi per il mondo. \u00c8 un servizio molto comodo e interessante, nel caso si voglia studiare la propagazione di un certo nome di dominio.</p> </li> </ul> <p> </p>"},{"location":"DNS/lab_DNS_server/","title":"DNS Server","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: OS, terminale</p> <p>Argomenti trattati: DNS, URL</p> <p>In questo capitolo andremo ad installare un server DNS su un dispositivo con OS Linux. Questo dispositivo monta una versione di Linux con package manager apt, quindi potrebbe essere un RaspberryPi oppure una installazione di Ubuntu Server.</p> <p>Il server DNS che andiamo ad installare si chiama BIND (https://www.isc.org/bind/). Bind \u00e8 un server DNS open source sviluppato dall'Internet Systems Consortium e che rappresenta il server DNS in assoluto pi\u00f9 utilizzato sulla rete Internet. Credo che molti (se non tutti i) server DNS della root zone siano implementati con Bind e cos\u00ec molti dei server autoritativi esistenti. Per quanto riguarda il mercato dei resolver invece... il problema si allarga.</p> <p>Per installare il server DNS BIND sul nostro OS, dopo un aggiornamento generale dei pacchetti installati, ci baster\u00e0 fare un semplice:</p> <pre><code>$ sudo apt install bind9\n</code></pre> <p>I file di configurazione dello stesso si trovano nella directory <code>/etc/bind</code>.  Il file principale si chiama <code>named.conf</code> che non contiene altro che riferimenti agli altri file che organizzano in questo modo la configurazione del server a blocchi indipendenti.</p> <p>Il file contiene gi\u00e0 nella sua installazione un elenco degli IP dei server della DNS root zone: il file <code>/usr/share/dns/root.hints</code>, quindi tecnicamente \u00e8 gi\u00e0 pronto a partire e funzionare come resolver per qualunque sito: avr\u00e0 bisogno solo di un p\u00f2 di tempo (e richieste) per costruire la sua cache e velocizzarsi.</p> <p>Avviatelo, eventualmente configuratelo come vostro server DNS e testatelo.</p> <p> </p>"},{"location":"DNS/py_dnspython/","title":"dnspython","text":""},{"location":"HTTP/HTTP/","title":"HTTP","text":""},{"location":"HTTP/HTTP/#il-protocollo-http","title":"Il protocollo HTTP","text":"<p>HTTP, acronimo di Hyper Textual Transfer Protocol, \u00e8 il protocollo utilizzato nella suite TCP/IP per il trasferimento di ipertesti. </p> <p>Come (sicuramente sappiamo) il <code>World Wide Web</code> (e dunque anche HTTP) \u00e8 stato inventato da Tim Berners Lee nel 1991! Chiaramente HTTP \u00e8 il protocollo alla base del www,  ma non \u00e8 l'unico protagonista in campo: ci sono i software (i client, cio\u00e8 i browser, e i server web), ci sono i linguaggi del web (HTML, CSS, JS, PHP, etc...), ci sono una marea di specifiche che devono collaborare per far funzionare il tutto!!!</p> <p>Per gestire tutte le specifiche del web \u00e8 stato dunque fondato un consorzio, dedicato espressamente allo sviluppo di ognuna delle sue parti considerata nel contesto pi\u00f9 ampio del web: il W3C (World Wide Web Consortium)! W3C non sviluppa direttamente il protocollo HTTP, ma verifica che le novit\u00e0 introdotte in esso tramite gli RFC siano compatibili con tutte le altre derivate dai linguaggi del web! </p> <p>Per quanto riguarda HTTP, la sua storia \u00e8 in piena evoluzione!!!</p> <p>La sua versione pi\u00f9 famosa \u00e8 probabilmente HTTP 1.1, pubblicata nel 1999 con il documento RFC 2616, che ha conciso con il boom della diffusione del web sul pianeta!</p> <p>La versione 2.0, incompatibile con la precedente, pubblicata come RFC 7540 nel maggio 2015, \u00e8 stata introdotta per migliorare le  performance del web 2.0 che aveva caratterizzato il decennio precedente.</p> <p>A fianco di questo momento di evoluzione del protocollo interviene anche il massiccio spostamento dei siti web verso il protocollo https,  che non \u00e8 per\u00f2 tecnicamente un vero protocollo, quanto un livello di sicurezza aggiuntivo, che si interpone fra HTTP e TCP assicurando la cifratura dei dati.</p> <p>La versione 3.0 uscita negli ultimi anni, ha richiesto una riorganizzazione completa dello Stack del web! Credo che per noi sia veramente troppo  arrivare a studiare questa specifica, ancora in fase di implementazione dai vari software web!!!</p> <p>Essendo HTTP un protocollo client/server necessita di due software per il suo funzionamento: i client web sono nient'altro che i comuni browser per la navigazione internet. C'\u00e8 poco da spiegare sui browser...</p> <p>I server web invece sono software progettati per distribuire le pagine web e i loro contenuti ai client richiedenti. Una semplice immagine dice pi\u00f9 di 1000 parole:</p> <p></p>"},{"location":"HTTP/HTTP/#il-protocollo-http-11","title":"Il protocollo HTTP 1.1","text":"<p>Il protocollo HTTP 1.1 \u00e8 un protocollo basato sulla tipologia client/server e sul meccanismo, comunissimo nelle comunicazioni di rete di alto livello, di request/reply (richiesta/risposta): il client esegue una richiesta ed il server restituisce la risposta e poi la connessione viene chiusa (protocollo stateless, senza stato, cio\u00e8 che non mantiene la connessione attiva).</p> <p>Il protocollo HTTP 1.1 si appoggia a livello di trasporto sul protocollo TCP e utilizza lato server la porta 80.</p> <p>Richiesta e risposta sono comunissimi file di testo: questo serve HTTP facile da implementare, gestire, studiare e \"controllare\".  Ogni coppia request/reply corrisponde ad un unico file da scambiare fra client e server: questo significa che se un sito \u00e8 costituito da una pagina con 50 immagini sono necessarie 51 richieste e risposte per ottenere tutto il suo contenuto!</p> <p></p> <p>Come descritto sopra esistono dunque due tipi di messaggi HTTP: i messaggi richiesta, inviati dai client HTTP e i messaggi risposta, inviati dai server web.</p> <p>In HTTP 1.1, Il messaggio di richiesta \u00e8 composto di tre parti:</p> <ol> <li>Riga di richiesta (request line)</li> <li>Sezione Header (informazioni aggiuntive)</li> <li>Body (corpo del messaggio)</li> </ol> <p>La riga di richiesta \u00e8 composta a sua volta da tre informazioni:</p> <ul> <li>la versione del protocollo: HTTP/1.1.</li> <li>il metodo di richiesta; per HTTP/1.1 sono disponibili i metodi GET, POST, HEAD, PUT, DELETE,TRACE, OPTIONS, CONNECT.</li> <li>L'<code>URL</code>; l'informazione che identifica l'oggetto della richiesta (ad esempio la pagina del sito che si vuole vedere).</li> </ul> <p>Fra i metodi elencati, vale la pena evidenziare il metodo GET, il pi\u00f9 utilizzato, che serve a richiedere una pagina specifica;  il metodo POST, utilizzato per inviare dati dal client al server;  il metodo PUT, utilizzato per l'upload di file, etc...</p> <p>Gli header di richiesta pi\u00f9 comuni sono:</p> <ul> <li>Host: Nome del server a cui si riferisce l'URI. \u00c8 obbligatorio     nelle richieste conformi HTTP/1.1 perch\u00e9 permette l'uso dei virtual     host basati sui nomi.</li> <li>User-Agent: Identificazione del tipo di client: tipo browser,     produttore, versione...</li> <li>Referer: indica l'URL che ha \"prodotto\" la richiesta corrente.</li> <li>Accept-Language: lista delle lingue che l'utente \u00e8 in grado di comprendere</li> </ul> <p>Il body contiene il corpo del messaggio. Il suo contenuto dipende dal metodo utilizzato:</p> <ul> <li>\u00e8 vuoto con il metodo GET</li> <li>contiene i dati da inviare con il metodo POST</li> <li>il file di cui fare l'upload con il metodo PUT</li> <li>etc...</li> </ul> <p>Esempio di richiesta HTTP 1.1</p> <pre><code>HTTP/1.1 GET \nHost: www.adjam.org\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 ...\nAccept-Language: it\n... (body) ...\n</code></pre> <p>Il messaggio di risposta \u00e8 composto sempre dalle seguenti tre parti, ognuna contenente una parte del messaggio da interpretare:</p> <ol> <li>Riga di stato (status-line)</li> <li>Sezione header</li> <li>Body (contenuto della risposta)</li> </ol> <p>La riga di stato riporta un codice a tre cifre che identifica il tipo di risposta. Per semplicit\u00e0, possiamo considerarla non come tre caratteri distinti, ma come un numero a tre cifre che va da 100 e 599. A seconda della cifra pi\u00f9 significativa del numero, la status-line riporta questi gruppi di informazioni:</p> <ul> <li>1xx: Informational (messaggi informativi, non di errore)</li> <li>2xx: Success (la richiesta \u00e8 stata soddisfatta)</li> <li>3xx: Redirection (la risorsa non \u00e8 presente, ma si hanno     informazioni su come raggiungerla)</li> <li>4xx: Client error (la richiesta non pu\u00f2 essere soddisfatta     perch\u00e9 sbagliata)</li> <li>5xx: Server error (la richiesta non pu\u00f2 essere soddisfatta per     un problema interno del server)</li> </ul> <p>Ovviamente non tutte le status line disponibili sono possibili. Wikipedia riporta un elenco aggiornato delle status line esistenti (http://en.wikipedia.org/wiki/List_of_HTTP_status_codes).</p> <p>Gli header della risposta pi\u00f9 comuni sono:</p> <ul> <li>Server: Indica tipo e versione del server</li> <li>Content-Type: Indica il tipo di contenuto restituito (tipo MIME).</li> <li>Content-encoding: Indica se il contenuto \u00e8 stato compresso oppure no.</li> <li>Content-length: Indica la lunghezza in byte del body</li> </ul> <p>Il body della risposta \u00e8 tipicamente il posto dove troviamo le informazioni trasportate: ad esempio, in caso di una richiesta GET, il body della risposta contiene il file da trasportare al client.</p> <p>Esempi di Risposta HTTP</p> <pre><code>HTTP/1.1 200 OK\nServer: Apache\nContent-Encoding: gzip\nContent-Length: 1122\nContent-Type: text/html\n... (seguita dal body coi dati richiesti) ...\n</code></pre>"},{"location":"HTTP/HTTP/#il-protocollo-http-20","title":"Il protocollo HTTP 2.0","text":"<p>Il protocollo HTTP 2.0 \u00e8 un protocollo basato sulla tipologia client/server e sul meccanismo richiesta/risposta.  Utilizza come la precedente versione la porta 80 lato server su TCP.</p> <p>La caratteristica principale di HTTP2 \u00e8 la sua ricerca della prestazione rispetto al predecessore  che ricercava invece la robustezza e la snellezza delle connessioni: essendo cambiati i tempi e le prestazioni della rete fisica, il protocollo \u00e8 stato rivisto per sfruttare al massimo le caratteristiche del protocollo TCP su cui si appoggia, arrivando alle seguenti conclusioni:</p> <ul> <li>HTTP2 cerca di minimizzare il numero delle connessioni TCP aperte (per la maggior parte dei casi ne basta una)      e di inviare tutti i dati in essa</li> <li>HTTP2 organizza i dati da inviare nell'ordine in cui il client dovrebbe leggerli e poi li comprime con un algoritmo di     compressione: questo fa s\u00ec che mentre HTTP 1.x invia dati in testo semplice, HTTP 2.x invia dati in modalit\u00e0 binaria, rendendo     impossibile ogni tipo di gestione o controllo.</li> </ul> <p>Anche qui... una immagine vale pi\u00f9 di tante parole:</p> <p></p> <p>In HTTP2 ogni pacchetto \u00e8 suddiviso in 2 parti:</p> <ol> <li>HEADER</li> <li>BODY</li> </ol> <p>Nell'header si trovano informazioni analoghe a quelle del protocollo precedente,  mentre il body contiene l'oggetto della richiesta (con la stessa logica di HTTP 1.1, come visto prima).</p> <p>Il risultato \u00e8 un unico file che verr\u00e0 poi compresso per ridurre le dimensioni e ottimizzare l'invio.</p> <p>Per valutare l'impatto sulle prestazioni che HTTP2 introduce nella rete Internet, esistono alcuni siti che rendono il confronto molto evidente, in particolare: https://imagekit.io/demo/http2-vs-http1.</p> <p>Un'altra novit\u00e0 che l'introduzione di HTTP 2.0 aggiunge \u00e8 forzare l'adozione di HTTPS per tutti i siti web: anche se tecnicamente HTTP2 \u00e8 un semplice sostituto di HTTP1 i browser pi\u00f9 comuni stanno forzando la richiesta di HTTP2 e HTTPS insieme.</p> <p>Vediamo dunque il funzionamento di HTTPS.</p> <p>(in realt\u00e0 no... perch\u00e9 non \u00e8 pronto...)</p> <p> </p>"},{"location":"HTTP/URL/","title":"URL: Uniform Resource Locator","text":"<p>Un URL \u00e8 una sequenza di caratteri compresi nel codice ASCII che identifica univocamente l'indirizzo di una risorsa in una rete. L'idea di base dell'invenzione degli URL \u00e8 quella di identificare ogni risorsa con un identificativo facile da ricordare (es: google.it, facebook.com) invece di avere informazioni dettagliate sull'indirizzo IP, il socket e il percorso relativo della risorsa.</p> <p>La struttura completa di ogni URL, definita nel RFC 3986, \u00e8 la seguente:</p> <p>scheme : // ( user ( : pass ) @ ) host ( :port ) ( /path ) ( ? query ) ( # fragment ) </p> <p>Nello schema sopraelencato le parentesi tonde indicano una informazione opzionale che, se presente, utilizza il separatore indicato. Ad esempio, se la query \u00e8 presente nell'URL \u00e8 sempre preceduta dal simbolo \"?\". L'host \u00e8 sempre presente. Pass e port, che sono entrambe precedute dal simbolo \":\" si distinguono perch\u00e9 una sta prima del simbolo \"@\" (e dell'host) e una dopo.</p> <p>Ognuna delle parti citate ha un significato identificativo per un concetto derivato dalla struttura dei protocolli che un URL pu\u00f2 identificare:</p> <p>SCHEME (o PROTOCOL) Descrive il protocollo da utilizzare per l'accesso ai server. Quando questa informazione \u00e8 assente, l'URL si dice relativo e sta al software che lo utilizza scegliere (con un po'di fortuna) il protocollo da utilizzare.</p> <p>USERINFO (= USER : PASS)  Specificano l'autenticazione per l'accesso alla risorsa.  Nel protocollo HTTP, questa modalit\u00e0 di  autenticazione \u00e8 ritenuta rischiosa per motivi di sicurezza e di phishing, mentre ad esempio,  gli account di posta sono scritti tipicamente come USER@HOST.</p> <p>HOST  rappresenta l'informazione che sar\u00e0 passata al server DNS per l'identificazione dell'indirizzo  IP del dispositivo in cui risiede la risorsa. \u00c9 l'informazione pi\u00f9 importante contenuta nell'URL.</p> <p>PORT  \u00e8 un numero compreso fra 1 e 65535 che serve per distinguere le connessioni dal punto di vista logico.  Molti protocolli utilizzano una porta fissa per identificare il server, in modo tale che questo numero venga spesso sottinteso.</p> <p>PATH  percorso relativo nel file system del server per raggiungere la risorsa.</p> <p>QUERY  Informazioni opzionali che devono essere elaborate dalla risorsa.</p> <p>FRAGMENT  identifica una parte specifica della risorsa.</p> <p> </p> <p>Vediamo insieme qualche esempio di URL per cercare di capire meglio!</p> <p>1) <code>http://www.liceodavincijesi.edu.it/area-studenti/</code></p> <p>Qui troviamo lo scheme (<code>http</code>) seguito dall'host (<code>liceodavincijesi.edu.it</code>) e dal path (<code>area-studenti</code>).  Non sono presenti altre componenti.</p> <p>2) <code>http://www.google.it/search?q=ciao</code></p> <p>Qui troviamo scheme (<code>http</code>), host (<code>www.google.it</code>), path (<code>search</code>) e query (<code>q=ciao</code>)</p> <p>3) <code>mailto:andrea@liceodavincijesi.edu.it</code></p> <p>Qui troviamo scheme (<code>mailto</code>), user (<code>andrea</code>) e host (<code>liceodavincijesi.edu.it</code>).  Lo schema mailto presenta una piccola eccezione alla regola in quanto non \u00e8 seguito dal doppio slash (//).</p> <p>4) <code>http://www.facebook.com@www.cicciobello.com/tihofregato/</code></p> <p>Se non hai cercato su internet il significato del termine phishing, in questo esempio trovi uno dei pi\u00f9 vecchi trucchi di mascheramento dell'identit\u00e0: qual \u00e8 l'host qui? Su quale sito sei?</p> <p> </p>"},{"location":"HTTP/lab_server_web/","title":"Sito web su Raspberry","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: Linux: terminale</p> <p>Argomenti trattati: HTTP, URL</p> <p>Linguaggi per il web introdotti: HTML, CSS, PHP</p> <p>Il nostro obiettivo \u00e8 installare un server web su Raspberry. La scelta del software ricadr\u00e0 ovviamente su Apache (https://www.apache.org).</p> <p>Apache \u00e8 il server web pi\u00f9 famoso e utilizzato nel mondo. Si \u00e8 sviluppato e migliorato assieme al protocollo HTTP e la sua struttura modulare gli permette di interagire anche con linguaggi di programmazione web lato server, come PHP, Perl, CGI o Python, per servire pagine dinamiche, oppure di implementare nuove specifiche opzionali, come il supporto per HTTP 2.0.</p> <p>Per installare Apache, dobbiamo accedere ad un terminale e, dopo aver verificato che il sistema sia aggiornato, installare il software:</p> <pre><code>$ sudo apt install apache2\n</code></pre> <p>Questa semplice istruzione si occupa di tutto, ovvero:</p> <ul> <li>scarica il pacchetto software contenente il web server Apache dalla Rete</li> <li>lo installa</li> <li>abilita il servizio Apache per l'attivazione</li> <li>attiva il servizio Apache</li> </ul> <p>Terminata l'esecuzione della linea di codice, si pu\u00f2 procedere direttamente a testare il webserver! Per collegarsi ad esso, ci basta aprire il sito <code>http://localhost/</code> e vedere la pagina iniziale!</p> <p></p> <p>Questo significa che l'installazione \u00e8 andata a buon fine! </p> <p>Per permettere a chiunque altro di vedere la nostra pagina possiamo utilizzare due strategie:</p> Utilizzando l'indirizzo IP <p>Questa opzione \u00e8 la migliore nel senso che funzioner\u00e0 con tutti i dispositivi che possono connettersi al proprio Raspberry. Dovete controllare l'indirizzo IP del Raspberry tramite il comando ip addr oppure tramite il comando ifconfig e poi far connettere chiunque a http://X.X.X.X/ dove (ovviamente) X.X.X.X \u00e8 l'indirizzo IP del Raspberry.</p> Utilizzando l'hostname del Raspberry <p>Questa opzione \u00e8 la pi\u00f9 semplice, ma pu\u00f2 funzionare solo se il nome \u00e8 registrato in un servizio DNS a cui entrambi i dispositivi (il Raspberry e il PC o il telefono da cui guardare il sito web). Si pu\u00f2 controllare l'hostname del Raspberry (se non lo ricordate) tramite il comando hostname -I</p>"},{"location":"HTTP/lab_server_web/#modificare-il-sito-web","title":"Modificare il sito web","text":"<p>I file che rappresentano il sito web esposto tramite Apache si trovano in una cartella (e fino a qui...). La cartella in questione \u00e8 la cartella <code>/var/www/html</code> quindi per accedervi e controllarne il contenuto dovete digitare:</p> <pre><code>$ cd /var/www/html\n$ ls -al\n</code></pre> <p>Questo comando vi mostrer\u00e0, oltre che all'elenco dei file, informazioni su di essi come il proprietario, la dimensione, etc... Una roba tipo questa:</p> <pre><code>total 12\ndrwxr-xr-x  2 root root 4096 Jan  8 01:29 .\ndrwxr-xr-x  3 root root 4096 Jan  8 01:28 ..\n-rw-r--r--  1 root root  177 Jan  8 01:29 index.html\n</code></pre> <p>In particolare vorrei farvi notare che il proprietario dei file del sito e della cartella che lo contiene \u00e8 il Signore Onnipotente: root! Questo significa che ogni operazione di modifica, cancellazione o aggiunta file dovrebbe essere fatta con sudo... Moooooolto noioso!</p> <p>Cambiamo il proprietario della cartella:</p> <pre><code>$ sudo chown pi /var/www/html -R\n</code></pre> <p>Adesso potete aprire i file e lavorare sulla cartella del sito anche con i programmi grafici :)</p>"},{"location":"HTTP/lab_server_web/#installare-php","title":"Installare PHP","text":"<p>PHP \u00e8 un linguaggio di programmazione web lato server; il suo nome \u00e8 uno di quegi acronimi ricorsivi che tanto piacciono agli informatici. PHP infatti sta per Php: Hypertext Preprocessor, richiamando il nome PHP.</p> <p>Esso \u00e8 un preprocessore: \u00e8 codice che viene eseguito quando il server web riceve una richiesta per una pagina web. La pagina richiesta \u00e8 dunque il programma che viene eseguito al momento della richiesta. L'esecuzione di quel codice crea dunque una pagina HTML al volo, una pagina dinamica, che sar\u00e0 poi rinviata all'utente tramite il server web.</p> <p>PHP \u00e8 il linguaggio di programmazione web lato server pi\u00f9 famoso: Facebook, Twitter e Wikipedia sono interamente scritti in PHP (e gi\u00e0 questi esempi bastano... mi pare).</p> <p>Per installare PHP \u00e8 sufficiente scrivere i seguenti comandi:</p> <pre><code>$ sudo apt install php\n$ sudo systemctl restart apache2\n</code></pre> <p>Per testare se tutto ha funzionato, basta scrivere una pagina, ad esempio test.php da salvare nella cartella principale del sito e scrivere il seguente codice:</p> <pre><code>&lt;?php\necho \"&lt;h1&gt;Ciao&lt;/h1&gt;\";\necho \"Sono la tua prima pagina in PHP :)\";\n?&gt;\n</code></pre> <p>Ovviamente, per vedere il risultato, bisogna puntare il browser su http://localhost/test.php</p> <p> </p>"},{"location":"HTTP/lab_sito_casa/","title":"Sito web a casa tua","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: PC oppure Raspberry, terminale. esperienza 'port forwarding'</p> <p>Argomenti trattati: HTTP, URL, DNS, livello di trasporto</p> <p>Linguaggi per il web introdotti: HTML, CSS, PHP</p> <p>S\u00ec, hai capito bene... proviamo a <code>hostare</code> un sito web a casa di ognuno di voi. Ovviamente sar\u00e0 un compito per casa e avr\u00e0 alcune condizioni...</p> <p>L'esperienza si snoda in 3 fasi distinte:</p> <ol> <li>installare un server web sul proprio dispositivo (PC/Raspberry)</li> <li>configurare il port forwarding fra il vostro dispositivo e il router     di casa</li> <li>aggiungere un DNS dinamico al vostro router in modo da rendere     semplicemente raggiungibile il sito</li> </ol>"},{"location":"HTTP/lab_sito_casa/#fase-1-web-server","title":"Fase 1: web server","text":"<p>Per quanto riguarda la prima fare, se avete un Raspberry (oppure un computer con Linux) potete consultare la guida sul server web qui sopra.</p> <p>Se avete solo un PC con Windows o Mac, potete installare un server web con XAMPP (https://www.apachefriends.org/index.html).</p> <p>Nella pagina linkata ci dovrebbe essere anche un video di 90 secondi che spiega come si installa. Potete tranquillamente deselezionare tutte le opzioni possibili (apache e php vengono installati per forza). Tutto qui!</p> <p>Create una pagina web semplice e divertente e salvatela come index.html nella cartella htdocs dentro la cartella xampp (magari rinominando quella presente inizialmente).</p>"},{"location":"HTTP/lab_sito_casa/#se-davvero-funziona","title":"Se davvero funziona...","text":"<p>Controllate l'IP del dispositivo in cui avete installato il server web e provate a collegarvi con il vostro telefono (collegato al wifi di casa) al sito http://IP_del_dispositivo.</p> <p>E se davvero funziona... potete gi\u00e0 cominciare ad essere soddisfatti di voi!</p>"},{"location":"HTTP/lab_sito_casa/#fase-2-port-forwarding","title":"Fase 2: port forwarding","text":"<p>Per quanto riguarda il port forwarding dovete seguire la guida a proposito nella sezione del livello di trasporto ed esporre la porta 80 del dispositivo in cui avete installato apache all'esterno.</p>"},{"location":"HTTP/lab_sito_casa/#se-davvero-funziona_1","title":"Se davvero funziona...","text":"<p>Controllate con un sito web tipo https://whatismyipaddress.com/ il vostro indirizzo pubblico e provate con il vostro telefono (non collegato al wifi) a collegarvi al sito http://vostro_IP_pubblico.</p> <p>E se davvero funziona... fate sapere al prof quanto siete tosti!!!</p>"},{"location":"HTTP/lab_sito_casa/#fase-3-dynamic-dns","title":"Fase 3: Dynamic DNS","text":"<p>Ultima fase... configurazione di un DNS dinamico per rendere il vostro sito raggiungibile con semplicit\u00e0 da chiunque!</p> <p>Al di l\u00e0 di questa fase c'\u00e8 lo zen delle conoscenze di rete, quindi non star\u00f2 a spiegarvi molto se non a darvi due imbeccate:</p> <ol> <li> <p>nei router solitamente \u00e8 gi\u00e0 presente il supporto per il DNS     dinamico. Provate a controllare nella sua interfaccia (lo avete gi\u00e0     fatto per il port forwarding) e utilizzate uno dei servizi indicati     l\u00ec.</p> </li> <li> <p>i servizi di DNS dinamico forniscono gratuitamente, per un periodo     limitato, host del terzo livello per alcuni servizi. Alcuni fra i     pi\u00f9 famosi siti per il DNS dinamico sono:</p> <ul> <li>https://dyndns.it/</li> <li>https://www.noip.com/</li> <li>https://cloudns.net/</li> </ul> </li> </ol> <p>Fatelo! Se volete un posto in paradiso... fatelo!</p>"},{"location":"HTTP/lab_sito_casa/#se-davvero-funziona_2","title":"Se davvero funziona...","text":"<p>Collegatevi tramite il vostro telefono (non collegato al wifi) al sito http://vostro.host.dinamico.</p> <p>E se davvero funziona... lasciate il dispositivo acceso per pavoneggiarvi a lezione con il prof estasiato e i vostri compagni ammirati.</p> <p> </p>"},{"location":"HTTP/lab_telnet_http/","title":"Telnet e HTTP","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: OS, terminale</p> <p>Argomenti trattati: Telnet, HTTP</p>"},{"location":"HTTP/lab_telnet_http/#introduzione","title":"Introduzione","text":"<p>Telnet \u00e8 un piccolo client da terminale, disponibile su ogni sistema operativo, che serve per simulare connessioni in chiaro a qualsiasi socket desideriamo. La sua utilit\u00e0 sta nel fatto che permette di dialogare con qualunque protocollo del livello superiore che utilizza testo semplice per le sua sintassi.</p> <p>A pensarci bene, tutti i protocolli del livello superiore che abbiamo studiato (o che studieremo) utilizzano dati codificati in ASCII, quindi... telnet pu\u00f2 essere un semplice strumento per provare ad analizzarli!</p> <p>La sua sintassi \u00e8 semplicissima:</p> <pre><code>$ telnet HOST PORT\n</code></pre> <p>Da dopo l'avvenuta connessione bisogna scrivere.. nella lingua del servizio con cui vogliamo dialogare, ovvero bisogna usare le specifiche del protocollo!</p>"},{"location":"HTTP/lab_telnet_http/#telnet-e-http-1","title":"TELNET e HTTP","text":"<p>Praticamente con telnet ci colleghiamo ad un server HTTP e poi possiamo provare a scrivere a mano una richiesta HTTP. Nell'esempio proviamo a connetterci al generico sito www.esempio.com e a chiedere la homepage con una richiesta GET.</p> <pre><code>$ telnet www.esempio.com 80\n\n... risposta ...\n\nGET / HTTP/1.1\nHost: www.esempio.com\n\n... risposta ...\nHTTP/1.1 200 OK\nDate: Wed, 21 Jan 2004 22:13:05 GMT\nServer: Apache/1.3.12-Turbo\nContent-Type: text/html\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Esempio&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Esempio&lt;/h1&gt;\nHai capito?\n&lt;/body&gt;\n&lt;html&gt;\n</code></pre> <p>Tutto qui... semplice, ma efficace! Secondo me, anche molto affascinante.</p> <p> </p>"},{"location":"HTTP/py_Flask/","title":"Python: Flask Web Framework","text":"<p>Uno Web Framework rappresenta una collezione di librerie e moduli che permette ad uno web developer  di scrivere applicazioni web senza occuparsi dei dettagli di basso livello.</p> <p>Flask \u00e8 uno Web Framework scritto in Python,  basato sul toolkit WSGI Werkzeug e sul template engine Jinja2.</p> <p>WSGI (Web Server Gateway Interface) \u00e8 una specifica che definisce una interfaccia universale  di comunicazione fra un server web e una applicazione web: Werkzeug \u00e8 semplicemente una implementazione  WSGI utilizzata da Flask.</p> <p>Jinja2 \u00e8 un template engine molto popolare per il linguaggio Python. Un sistema di web template combina  un template (uno schema, uno scheletro) con delle sorgenti dati per creare una pagina web dinamica.</p> <p>Flask \u00e8 disponibile in pochi istanti tramite pip:</p> <pre><code>$ pip install Flask\n</code></pre> <p>Oppure dall'interfaccia di Thonny per la gestione dei pacchetti (sottinteso: cerca Flask... Installa... Attendi... Boom!)</p>"},{"location":"HTTP/py_Flask/#primi-esempi-con-flask","title":"Primi esempi con Flask","text":"<p>La pi\u00f9 semplice applicazione sviluppabile con la libreria Flask \u00e8 strutturata in questo modo:</p> <pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index():\n    return \"Hello, World!\"\n</code></pre> <p>Se la eseguite con Thonny essa creera un avviso tipo questo:</p> <pre><code># Running the app with options chosen by Thonny. See Help for details.\n* Serving Flask app 'HelloWorld' (lazy loading)\n* Environment: development\n* Debug mode: off\n* Running on **http://127.0.0.1:5000/** (Press CTRL+C to quit)\n</code></pre> <p>Cliccando sul link http://127.0.0.1:5000/ o aprendolo direttamente nel browser vedremo una pagina semplice semplice con scritto \"Hello, World!\".</p> <p>A vederlo cos\u00ec non sembra difficile, ma ci sono alcune cosine che risultano un po' strane a prima vista, provo a commentare tutto questo primo codice e a spiegare la logica con cui si sviluppa utilizzando Flask.</p> <p>Importiamo l'oggetto Flask dal modulo flask</p> <pre><code>from flask import Flask\n</code></pre> <p>Questa operazione \u00e8 l'operazione di base per lavorare con il modulo Flask: non c'\u00e8 molto altro da commentare se non che siamo gi\u00e0 pratici di questa modalit\u00e0 e che arriveranno man mano altri oggetti dal modulo flask, secondo necessit\u00e0.</p> <p>Creiamo l'oggetto Flask che gestisce la nostra applicazione</p> <pre><code>app = Flask(__name__)\n</code></pre> <p>Tecnicamente questo oggetto rappresenta il server web... ovvero il software che fornisce le pagine web agli utenti (che le richiedono tramite i browser).</p> <p>Per funzionare ha bisogno di un nome (si possono eseguire pi\u00f9 oggetti contemporaneamente, ma devono avere nome diverso).</p> <p>Definiamo la funzione da eseguire.</p> <pre><code>def index():\n    return \"Hello, World!\"\n</code></pre> <p>Lo so, ho saltato la riga \"complicata\". Ma siccome ho bisogno di pi\u00f9 spazio per spiegarla... faccio prima questa che \u00e8 facile.</p> <p>La funzione in oggetto si chiama come vi pare e restituisce una stringa: quella stringa sar\u00e0 il contenuto della pagina web che vedremo sul browser.</p> <p>Impostiamo il decoratore della nostra applicazione</p> <pre><code>@app.route(\"/\")\n</code></pre> <p>Un <code>decoratore</code> \u00e8 una struttura Python relativamente complessa che si abbina ad una funzione  (quella che indicate sotto alla riga con la @) e che ne modifica il comportamento (la decora).</p> <p>Il decoratore <code>route</code>, definito nella classe Flask di cui app \u00e8 un oggetto si comporta in questo modo:  quando il PATH dell'URL richiesto corrisponde al suo parametro esegue la funzione abbinata e restituisce come contenuto della pagina WEB ci\u00f2 che la funzione ritorna.</p> <p>Il decoratore del nostro esempio viene scatenato perch\u00e9 il link in questione \u00e8 http://127.0.0.1:5000/:  il PATH di questo URL \u00e8 effettivamente la stringa \"/\".</p> <p>Se volessimo \"aggiungere una pagina\" al nostro sito, raggiungibile all'URL http://127.0.0.1:5000/nuovapagina allora dovremmo aggiungere al nostro codice un nuovo decoratore abbinato ad una nuova funzione: una cosa del tipo</p> <pre><code>@app.route(\"/nuovapagina/\")\ndef nuovapagina():\n    s = \"&lt;h1&gt;Ciao&lt;/h1&gt;\n    s += \"Sei sull'altra pagina...\"\n    return s\n</code></pre> <p>Spero sia tutto chiaro fin qui!</p> <p>Avrete notato che Thonny esegue la app di Flask nell'indirizzo locale <code>127.0.0.1</code>,  che non \u00e8 raggiungibile dall'esterno. Per cambiare questo comportamento, eseguite in maniera esplicita la funzione <code>run()</code> terminando il codice con una cosa tipo:</p> <pre><code>if __name__ == \"__main__\":\n    app.run(host = \"0.0.0.0\", port = 5000, debug = False)\n</code></pre>"},{"location":"HTTP/py_Flask/#esercizio-svolto","title":"Esercizio svolto","text":"<p>Ho scritto la mia bella pagina web in HTML, CSS, JS e via discorrendo. Ho tutto pronto nel file \"pagina.html\": come la rendo disponibile online?</p> <p>Nella stessa cartella della pagina web creo uno script Python con il seguente codice:</p> <pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index():\n    file = open(\"pagina.html\")\n    content = file.read()\n    file.close()\n    return content\n</code></pre>"},{"location":"HTTP/py_Flask/#lesercizio-svolto-e-sbagliato","title":"L'esercizio svolto \u00e8 sbagliato!","text":"<p>In che senso sbagliato... l'esercizio \u00e8 giusto. Funziona! L'ho appena provato... inoltre ha senso, combacia con la teoria spiegata nella pagina precedente... Cosa ha di sbagliato?</p> <p>In realt\u00e0 nulla.</p> <p>Il fatto \u00e8 che tramite Flask \u00e8 possibile fare le cose in maniera addirittura pi\u00f9 semplice!</p> <p>Ho provato a disegnare uno schema per spiegare il concetto... se a sinistra (on the web) descrivo come scriveresti una normale pagina web, a destra (on the Flask framework) descrivo come andrebbero organizzati i file.</p> <p></p> <p>Il web framework Flask considera (scontata) la presenza di 2 directory:</p> <ul> <li>la cartella static, che andr\u00e0 a contenere tutti file \"statici\"     del sito: immagini, css, javascript, etc...</li> <li>la cartella templates, che andr\u00e0 a contenere tutti i file html     del sito. Vengono definiti templates e non sono considerati statici     perch\u00e9 possono essere completati o modificati tramite codice andando     a creare contenuti dinamici.</li> </ul> <p>Quando si utilizza la cartella templates, il (poco) lavoro svolto nell'esempio svolto  si fa in meno di una riga di codice, tramite la funzione <code>render_template</code></p> <pre><code>from flask import Flask,render_template\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"pagina.html\")\n</code></pre>"},{"location":"HTTP/py_Flask/#variabili-dinamiche","title":"Variabili dinamiche","text":"<p>Nel parametro del decoratore \u00e8 possibile inserire delle variabili dinamiche marcando  alcune parole con le parentesi angolari: <code>&lt;variable&gt;</code>.</p> <p>Questo \u00e8 uno di quegli innumerevoli casi in cui un esempio vale pi\u00f9 di mille parole...</p> <pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/post/&lt;id&gt;\")\ndef showPost(id):\n    # do something...\n    return \"the post you're searching for has id \" + id\n\n@app.route(\"/&lt;name&gt;\")\ndef test(name):\n    return \"Hello \" + name\n\n@app.route(\"/&lt;val1&gt;/&lt;val2&gt;\")\ndef dai(val1, val2):\n    return \"val 1 = \" + val1 + \", val 2 = \" + val2\n</code></pre> <p>Come vedete, \u00e8 possibile generare una pagina specifica a seconda dell'URL utilizzato e avendo magari un \"template\" di riferimento per la stessa...</p> <p>In effetti \u00e8 proprio cos\u00ec: guardate che roba.</p> <p>Create una pagina web chiamata welcome.html in cui digitate il seguente codice HTML</p> <pre><code>&lt;h1&gt;Ciao!&lt;/h1&gt;\n\nSo che ti chiami {{ nome_utente }}\n</code></pre> <p>Come vedete questa sintassi non \u00e8 esattamente HTML... questo \u00e8 Jinja2, quel web template  che dicevamo permette di creare pagine dinamiche... ricordate?</p> <p>Salvata la pagina nella cartella dei templates, il codice che la fa funzionare \u00e8 semplicemente questo:</p> <pre><code>from flask import Flask,render_template\n\napp = Flask(__name__)\n\n@app.route(\"/user/&lt;name&gt;\")\ndef index(name):\n    return render_template(\"pagina.html\", nome_utente=name)\n</code></pre> <p>Adesso vi basta eseguire questo script e visitare il link http://127.0.0.1:5000/user/unnomequalsiasi ...</p>"},{"location":"HTTP/py_Flask/#redirection-behaviour","title":"Redirection Behaviour","text":"<p>Le due seguenti route sono diverse per la presenza o meno dello slash finale:</p> <pre><code>@app.route(\"/home/\")\ndef home():\n    return \"the home page\"\n\n@app.route(\"/about\")\ndef about():\n    return \"the about page\"\n</code></pre> <p>Nel primo caso (con lo slash alla fine) Flask immagina di riferirsi ad una cartella (da cui pescare il file index.html): se l'utente digita l'URL <code>http://host:port/home</code> (senza slash) Flask automaticamente lo aggiunge per riferirsi (correttamente) alla cartella home.</p> <p>Nel secondo caso (senza lo slash finale) Flask immagina che la pagina about sia solo una pagina: se l'utente digita l'URL <code>http://host:port/about</code> (senza slash) tutto funziona normalmente, ma se l'utente aggiunge lo slash finale (digitando http://host:port/about/) Flask ritorna un errore 404 di pagina non trovata.</p>"},{"location":"HTTP/py_Flask/#gestione-form","title":"Gestione form","text":"<p>Un'altra cosa molto interessante che \u00e8 possibile fare con il modulo Flask \u00e8 la gestione dei dati scambiati fra client e server, tipicamente inviati con metodo POST (a volte anche con una semplice GET), quando ad esempio si compila un form di iscrizione, si risponde ad un sondaggio sul web o si mettono le proprie credenziali per accedere ad un servizio.</p> <p>Per spiegare nella maniera pi\u00f9 semplice possibile questa funzionalit\u00e0 ho realizzato un esempio molto semplice in cui l'utente si trova davanti due caselle di testo per inserire nome utente e password e Flask raccoglie i dati e li rivisualizza come dimostrazione di averli letti.</p> <p>Entrambe le pagine saranno servite dalla nostra applicazione Flask.</p> <p>La pagina con il form HTML</p> <pre><code>&lt;form action=\"/data\" method=\"POST\"&gt;\n\nUSER: &lt;input name=\"username\"&gt;&lt;br&gt;\nPASS: &lt;input name=\"password\" type=\"password\"&gt;&lt;br&gt;\n\n&lt;input type=\"submit\" value=\"INVIA\"&gt;\n&lt;/form&gt;\n</code></pre> <p>Ovviamente l'esempio \u00e8 molto scarno, ma gi\u00e0 sufficiente per la comprensione. Il metodo di invio \u00e8 <code>POST</code>, i dati da inviare sono 2, identificati dai nomi <code>username</code> e <code>password</code>. La pagina a cui questi dati saranno inviati si trova all'URL relativo <code>/data</code>.</p> <p>Suggerimento</p> <p>Se possibile, quando si usa Flask (e Python in genere), evitate di utilizzare il nome pass, che corrisponde ad una precisa istruzione Python...  meglio evitare confusione!!!</p> <p>La pagina si chiamer\u00e0 \"login.html\" e sar\u00e0 ovviamente collocata nella cartella \"templates\" della nostra app.</p> <p>La pagina per visualizzare i dati:</p> <pre><code>USER: {{ username }} &lt;br&gt;\nPASS: {{ password }} &lt;br&gt;\n</code></pre> <p>Ovviamente non ha molto senso visualizzare l'username e la password. Noi qui lo facciamo solo per dimostrare che la lettura \u00e8 andata a buon fine.</p> <p>La pagina si chiamer\u00e0 \"dati.html\" e (anche questa) sar\u00e0 collocata nella cartella \"templates\".</p> <p>Il codice Python Flask</p> <pre><code>from flask import Flask,render_template,request\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"login.html\")\n\n@app.route(\"/data\", methods=[\"POST\"])\ndef login():\n    u = request.form[\"username\"]\n    p = request.form[\"password\"]\n    return render_template(\"data.html\",username = u,password = p)\n</code></pre> <p>Come vedete il codice introduce un nuovo oggetto: <code>request</code>.</p> <p>Questo oggetto serve per la gestione delle richieste, dei dati che esse veicolano e cos\u00ec via.</p> <p>Ancora una volta si utilizza il web template Jinja2 per la compilazione dei dati... mi sembra davvero molto comodo, invece che fare congiunzioni e magie con le stringhe.</p> <p>Il metodo di invio (POST, nel nostro caso) va indicato nel decoratore.</p> <p>Fatto!</p> <p>Detto tutto questo... basta provare!</p> <p> </p> <p> </p>"},{"location":"HTTP/py_bs4/","title":"Python: Beautiful soup 4","text":"<p>Blah blah</p> <p> </p>"},{"location":"HTTP/py_requests/","title":"Python requests","text":"<p>Il venerabile modulo <code>requests</code> \u00e8 lo standard de facto in Python per realizzare, gestire, analizzare richieste e risposte HTTP. Questa libreria non fa parte della dotazione ufficiale standard e va quindi installata, tramite l'interfaccia di Thonny o tramite il comando:</p> <pre><code>pip install requests\n</code></pre> <p>Il protocollo HTTP</p> <p>Se siete qui a studiare il modulo <code>requests</code>, si presuppone abbiate gi\u00e0 una discreta conoscenza del protocollo HTTP.</p> <p>In caso contrario... molte cose rimarranno oscure e/o meccaniche.</p> <p>La sintassi di base del modulo \u00e8 strutturata nel modo seguente:</p> <pre><code>import requests\n\n# method \u00e8 una funzione generica per uno dei metodi HTTP: get, post, put, head ... etc...\nresponse = requests.method( URL , options )\n</code></pre>"},{"location":"HTTP/py_requests/#richieste-get","title":"Richieste GET","text":"<p>Vedi: https://realpython.com/python-requests/</p> <p> </p>"},{"location":"HTTP/py_urllib/","title":"urllib","text":""},{"location":"MAIL/MAIL/","title":"La posta elettronica","text":"<p>Simple Mail Transfer Protocol \u00e8 il protocollo standard per la trasmissione via internet di e-mail.  Progettato nel 1982 tramite il documento RFC 821, ha subito ben 2 revisioni importanti con RFC 2821 (2001) ed  RFC 5321 (2008),  entrambi tentativi mal riusciti, come vedremo, di aggiustare un protocollo \"broken by design\" per le necessit\u00e0 del web moderno.</p> <p>SMTP non \u00e8 un protocollo basato sul paradigma client/server perch\u00e9 le risorse (le mail) non sono disponibili sull'ipotetico server, ma nelle mani e nella testa degli utenti, che non hanno intenzione di inviarle ad un \"software\" ma che vogliono utilizzarle per comunicare con un altro utente.</p> <p>Il software che implementa il trasferimento delle mail tramite SMTP si chiama MTA (Mail Transport Agent) e, analogamente ad un server, sta in ascolto su una well known port, la porta 25/TCP.</p> <p>Gli URL che identificano i \"recipienti\" (le caselle di posta) contenenti le risorse (le mail) sono nient'altro che gli indirizzi di posta elettronica, nella forma user@host.</p> <p>Per risolvere l'host che identifica l'MTA che gestisce le sue caselle di posta SMTP utilizza un particolare record DNS denominato MX (Mail Exchange).</p> <p>Poich\u00e9 SMTP \u00e8 un protocollo testuale basato sulla codifica ASCII, non \u00e8 permesso trasmettere direttamente testo composto con un diverso set di caratteri e tanto meno file binari. Vedremo pi\u00f9 avanti che per aggirare questo ostacolo e inviare file binari tramite SMTP (chi non ha mai allegato ad una mail un file pdf, una immagine o un file mp3?) si utilizzano i <code>MIME Types</code>, uno standard che permette di estendere il formato dei messaggi permettendo di inviare dati binari come fossero file di testo semplice.</p>"},{"location":"MAIL/MAIL/#smtp-e-protocolli-ausiliari","title":"SMTP e protocolli ausiliari","text":"<p>SMTP \u00e8 un protocollo che permette soltanto di inviare messaggi di posta, ma non di riceverli!</p> <p>Sparata la frase ad effetto, spieghiamo meglio: SMTP gestisce lo scambio di messaggi fra gli MTA, ovvero i software che gestiscono le caselle di posta e lo scambio di messaggi fra queste.</p> <p>Allora immaginiamo di avere a che fare con 2 MTA, quello che gestisce le caselle di posta <code>paperopoli.com</code> e quello che gestisce le caselle di posta <code>topolinia.net</code>.</p> <p>Paperino ha un account di posta su paperopoli.com, mentre Pippo ne ha uno su topolinia.net.</p> <p></p> <p>Quando paperino@paperopoli.com invia una mail a pippo@topolinia.net, Pippo non riceve la mail in maniera istantanea nel suo dispositivo!  La mail inviata da Paperino va a finire nella casella di Pippo nell'MTA identificato dall'host <code>topolinia.net</code>.</p> <p>Quando Pippo decide di controllare la posta si collega al suo server tramite un protocollo ausiliario e si fa una copia della posta per la sua comoda lettura. I protocolli ausiliari fra cui scegliere per ricevere la posta sono solo due: POP e IMAP.</p> <p>POP (Post Office Protocol) \u00e8 un protocollo del livello superiore di tipo client-server che permette, previa autenticazione, di eseguire sul client una copia delle mail presenti sul server. Le mail per essere lette devono essere copiate sul dispositivo utente locale. A quel punto la posta pu\u00f2 essere rimossa dal server e l'unica copia della posta \u00e8 quella che rimane sul client.</p> <p>IMAP (Internet Message Access Protocol) \u00e8 un altro protocollo del livello superiore ausiliario alla posta. Tipicamente IMAP viene considerato come \"l'alternativa moderna\" al protocollo POP!</p> <p>La sua caratteristica principale sta nel fatto che, a differenza di POP, mantiene una copia sincronizzata delle mail fra client e server, mantenendo sempre aggiornata la copia lato server di tutte le modifiche, mail lette, cancellate, risposte, etc...</p> <p>Questo lo rende molto adatto all'utilizzo multiutente e/o alla consultazione multi-dispositivo. Inoltre permette l'accesso sia online che off-line alla posta (una volta scaricata. Alla successiva connessione, le modifiche sul client saranno sincronizzate sul server) e alla ricerca diretta sul server delle mail.</p> <p>\u00c8 molto importante sottolineare che i 3 protocolli SMTP, POP, IMAP sono protocolli che gestiscono e inviano semplici file di testo e non prevedono alcuna cifratura!</p> <p>Mi preme inoltre sottolineare che, mentre POP e IMAP utilizzano almeno la password utente per l'identificazione, bench\u00e9 la inviino in chiaro, il protocollo SMTP per l'invio dei messaggi non prevede neppure l'autenticazione!!</p> <p>Non so davvero scegliere la scelta peggiore...</p> <p>Per consultare la posta gli utenti utilizzano ovviamente un software: l'applicazione sul telefono, il sito web che mi fa vedere la mail, l'applicazione desktop che mi permette di consultarla... tutti questi software vengono definiti MUA (Mail User Agent). Impropriamente ci si riferisce a questi come ai client di posta, poich\u00e9 devono interagire con il protocollo SMTP per l'invio delle mail e con POP oppure IMAP (a seconda della scelta dell'utente) per la ricezione.</p>"},{"location":"MAIL/MAIL/#smtp-e-sicurezza","title":"SMTP e sicurezza","text":"<p>Una delle (tante) limitazioni del protocollo SMTP originario \u00e8 che non gestisce l'autenticazione dei mittenti. Questo problema madornale dipende da motivazioni \"storiche\"... SMTP \u00e8 stato pensato negli anni '80 per lo scambio di informazioni e documenti in ufficio (da cui la sua \"aria\" sempre un po' seriosa...): la sicurezza non era un problema da considerare.</p> <p>Se proiettiamo queste caratteristiche nella Internet del nuovo millennio c'\u00e8 poco da fare! Con SMTP lo spam non \u00e8 un rischio, \u00e8 una certezza...</p> <p>Il problema principale della posta elettronica in generale \u00e8, paradossalmente, il fatto che abbia avuto una cos\u00ec grande diffusione! E' impensabile nel mondo di oggi sostituire SMTP con una implementazione alternativa e sicura.</p> <p>L'unica soluzione attuabile \u00e8 quella di estendere in maniera retro-compatibile il protocollo attuale.</p> <p>Ecco spiegata la necessit\u00e0 delle due grandi revisioni del protocollo SMTP (e dei suoi protocolli ausiliari), invece magari di inventare un protocollo ex-novo, pi\u00f9 moderno e pi\u00f9 adatto alle necessit\u00e0 di oggi.</p> <p>Nella prima revisione la novit\u00e0 pi\u00f9 importante \u00e8 stata quella della estensione cosiddetta SMTP-AUTH, che obbliga gli utenti a utilizzare la password per inviare la posta. In chiaro, ovviamente...</p> <p>Nella seconda revisione (molto importante) si \u00e8 finalmente arrivati a progettare delle estensioni in grado di criptare il traffico SMTP (e IMAP, e POP) in maniera analoga alla crittografia di HTTPS.</p> <p>L'introduzione di queste estensioni nei sistemi dei maggiori fornitori di indirizzi di posta elettronica ha avuto l'effetto di ridurre, ma non debellare i problemi relativi alla sicurezza: lo spam, il phishing e le truffe in genere via mail sono purtroppo ancora all'ordine del giorno.</p>"},{"location":"MAIL/MAIL/#mime-types","title":"MIME Types","text":"<p>Il MIME Type (Multipurpose Internet Mail Extensions) \u00e9 uno standard di Internet che definisce il formato dei dati trasportati tramite mail. Successivamente la tipizzazione MIME \u00e8 stata introdotta anche per le pagine web, cosicch\u00e9 ormai SMTP e HTTP la supportano entrambi pienamente.</p> <p>La trasmissione base dei dati supporta solo caratteri ASCII a 7 bit, caratteristica sufficiente per mail e semplici pagine web, ma non per le decine di file multimediali che ormai riempono la rete. Il MIME definisce meccanismi atti a spedire contenuti binari come immagini, suoni e filmati, oppure programmi, \"ingannando\" il protocollo che lo utilizza (HTTP o SMTP) e facendo passare i dati come normali dati di testo.</p> <p>Lo standard MIME \u00e8 espandibile. Le sue definizioni includono metodi per definire nuovi tipi di contenuto e altri attributi MIME. I tipi di contenuto predefiniti sono sette, di cui 5 sono tipi elementari:</p> <ul> <li>text,</li> <li>audio,</li> <li>image,</li> <li>video,</li> <li>application.</li> </ul> <p>Altri 2 sono tipi composti:</p> <ul> <li>message,</li> <li>multipart.</li> </ul> <p>Ognuno di questi ha opportuni sottotipi, come <code>image/png</code> o <code>application/zip</code>.  Il tipo MIME viene appeso come un header al contenuto del pacchetto inviato e viene utilizzato dal destinatario per interpretare correttamente i dati arrivati.</p> <p> </p>"},{"location":"MAIL/lab_mail_server/","title":"Mail Server","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: Raspberry, terminale linux</p> <p>Argomenti trattati: SMTP, POP, IMAP, URL, DNS</p> <p>L'idea \u00e8 quella di implementare un Mail Server completo su Raspberry, con un MTA per il protocollo SMTP, un server POP e un server IMAP per la ricezione, l'invio e lo smistamento della posta elettronica.</p> <p>Prima di andare avanti, ricordiamoci di aggiornare il sistema, ripulire e riavviare.</p> <pre><code>$ sudo apt update\n$ sudo apt upgrade\n$ sudo apt autoremove\n$ sudo reboot\n</code></pre>"},{"location":"MAIL/lab_mail_server/#configurare-lhostname","title":"Configurare l'hostname","text":"<p>La prima cosa da fare per raggiungere il nostro obiettivo \u00e8 di sistemare l'FQDN (Fully Qualified Domain Name) del nostro computer. Nel mio esempio esso sar\u00e0:</p> <ul> <li>HOSTNAME: raspberrypi</li> <li>DOMAIN NAME: scuola.lan</li> </ul> <p>l'FQDN che identifica il sistema sar\u00e0 dunque raspberrypi.scuola.lan con il servizio di posta installato in esso a servire il dominio @scuola.lan.</p> <p>Mail e DNS</p> <p>Se durante l'esperienza di gestione della posta si vuole configurare anche il DNS, ricordatevi che dovete creare una zona autoritativa per il primo livello .lan e configurare in essa almeno i seguenti record:</p> <p><code>Record A: scuola.lan</code>: Punta l'IP del Raspberry.</p> <p><code>Record A: raspberrypi.scuola.lan</code>: Punta l'IP del Raspberry.</p> <p><code>Record MX: scuola.lan</code>: Punta il record A raspberrypi.scuola.lan</p> <p>Volendo \u00e8 possibile aggiungere anche i terzi livelli <code>mail</code>, <code>pop</code>, <code>imap</code> (su record A) tutti che puntano l'IP del Raspberry.</p> <p>Per impostare FQDN come desiderato, eseguiamo i seguenti compiti:</p> <p>Task 1: Modifica del file <code>host.conf</code></p> <pre><code>$ sudo nano /etc/host.conf\n\norder hosts,bind\nmulti on\n</code></pre> <p>Task 2: Modifica hostname completo (FQDN)</p> <pre><code>$ sudo hostnamectl set-hostname raspberrypi.scuola.lan\n</code></pre> <p>Tassk 3: Modifica file <code>hosts</code></p> <pre><code>$ sudo nano /etc/hosts\n\n127.0.0.1       localhost\n127.0.1.1       raspberrypi.scuola.lan  raspberrypi\n</code></pre> <p>Riavvia il Raspberry e poi controlla il risultato con:</p> <pre><code>$ hostname --short\nraspberrypi\n\n$ hostname --domain\nscuola.lan\n\n# hostname --fqdn\nraspberrypi.scuola.lan\n</code></pre>"},{"location":"MAIL/lab_mail_server/#installare-postfix","title":"Installare Postfix","text":"<p>L'installazione \u00e8 (come al solito) una riga di codice:</p> <pre><code>$ sudo apt install postfix\n</code></pre> <p>Al termine dell'installazione c'\u00e8 una fase iniziale di configurazione in cui verranno poste due domande:</p> <ol> <li>il target del sistema di posta: selezionare INTERNET</li> <li>il nome di host del sistema di posta: inserire il nome di dominio.     Nel nostro esempio: scuola.lan.</li> </ol> <p>Fatto questo vanno configurati alcuni file per il nostro caso specifico:</p> <pre><code>$ sudo cp /etc/postfix/main.cf /etc/postfix/main.cf.BACKUP\n$ sudo nano /etc/postfix/main.cf\n\nsmtpd_banner = $myhostname ESMTP $mail_name (Raspbian)\nbiff = no\n\n# appending .domain is the MUA's job.\nappend_dot_mydomain = no\nreadme_directory = no\n\n# defaults to 2 on fresh installs\ncompatibility_level = 2\n\n# TLS parameters\nsmtpd_use_tls=no\n\n# general\nmyhostname = raspberrypi.scuola.lan\nmydomain = scuola.lan\n\nalias_maps = hash:/etc/aliases\nalias_database = hash:/etc/aliases\n\nmydestination = $mydomain, $myhostname, localhost\nrelayhost = \nmynetworks = 127.0.0.0/8 172.25.37.0/24\nmailbox_size_limit = 0\nrecipient_delimiter = +\ninet_interfaces = all\ninet_protocols = ipv4\n\n# use Maildir instead of mbox\nhome_mailbox = Maildir/\n</code></pre> <p>Sistemate i valori delle variabili <code>myhostname</code>, <code>mydomain</code> e <code>mynetworks</code> in base alle vostre necessit\u00e0.</p> <p>MAILDIR vs BOX</p> <p>Nell'ultima riga del file abbiamo impostato il sistema Maildir di gestione della casella di posta invece del metodo di default chiamato mbox.</p> <p>In questo modo il sistema sistemer\u00e0 la posta degli utenti nella cartella Maildir di ogni home, con evidenti vantaggi per l'amministratore (basta creare un utente per assicurargli anche una casella di posta) e per la sicurezza (nessun file esterno alla propria home a cui dover accedere).</p> <p>Fatto questo siamo pronti per il primo step, l'avvio dell'MTA Postfix:</p> <pre><code>$ sudo systemctl start postfix\n$ sudo systemctl status postfix\n</code></pre>"},{"location":"MAIL/lab_mail_server/#aggiungere-utenti","title":"Aggiungere utenti","text":"<p>Ogni utente che aggiungeremo al sistema operativo che ospita l'MTA avr\u00e0 una casella di posta della forma <code>user@scuola.lan</code>.</p> <p>Nei nostri test a scuola io aggiungo di solito una ventina di utenti con nome utente e password uguali a <code>studXX</code> con XX che va da 01 a 20 (o 25, o 30, a seconda della quinta...).</p> <p>Per fare un esperimento che ha senso occorre aggiungere almeno due utenti. Per farlo decidete i nomi e poi eseguite per ogni utente l'utitlity adduser come amministratore, cos\u00ec:</p> <pre><code>$ sudo adduser NOME_UTENTE_DA_CREARE\n</code></pre> <p>Poi rispondete a tutte le domande che vengono poste. Oppure saltatele tutte premendo INVIO, meno quelle sulla password (da inserire 2 volte).</p> <p>Tutto qui!</p>"},{"location":"MAIL/lab_mail_server/#server-pop-e-imap","title":"Server POP e IMAP","text":"<p>Per i server POP e IMAP si usa spesso la soluzione modulare dovecot, un software che contiene come moduli tutti i software di supporto ad un MTA. A noi servono i server POP e IMAP e l'installazione \u00e8 semplice come al solito.</p> <pre><code>$ sudo apt install dovecot-pop3d dovecot-imapd\n</code></pre> <p>La configurazione di entrambi i moduli si basa su pochi file che dobbiamo modificare per il funzionamento classico che ci interessa.</p> <p>Primo file, il file di configurazione principale <code>dovecot.conf</code> che va impostato per accettare tutte le connessioni in ingresso:</p> <pre><code>$ sudo nano /etc/dovecot/dovecot.conf\n\nlisten = *\n</code></pre> <p>Secondo file, quello che specifica quale tipo di contenitore di posta utilizza l'MTA</p> <pre><code>$ sudo nano /etc/dovecot/conf.d/10-mail.conf\n\nmail_location = maildir:~/Maildir\n</code></pre> <p>Terzo e ultimo file, quello che configurare l'accesso senza cifratura</p> <pre><code>$ sudo nano /etc/dovecot/conf.d/10-auth.conf\n\ndisable_plaintext_auth = no\nauth_mechanisms = plain login\n</code></pre> <p>Salvato tutto, basta avviare e controllare:</p> <pre><code>$ sudo systemctl start dovecot\n$ sudo systemctl status dovecot\n</code></pre>"},{"location":"MAIL/lab_mail_server/#mail-test","title":"Mail Test","text":"<p>Per fare un test approfondito dell'ambaradan che abbiamo messo su occorrerebbe testare il sistema con almeno 3 MUA (Mail User Agent), di cui almeno 2 configurati per la ricezione con IMAP (per testare la possibilit\u00e0 di ritrovare la mail in entrambi) e almeno uno con POP verificando successivamente con uno dei client IMAP che la posta \u00e8 effettivamente scomparsa.</p> <p>Si pu\u00f2 inoltre provare anche l'esperienza Telnet e Mail da qualche parte in questo stesso sito.</p> <p>Per quanto riguarda i MUA provo a suggerirvi alcuni software da testare da soli:</p> <ul> <li>le web applications <code>squirrelmail</code> (http://squirrelmail.org) oppure <code>rainloop</code> (https://rainloop.net).    Necessitano entrambe di un server web con PHP. Sono entrambe forzatamente client IMAP</li> <li>l'applicazione <code>E-Mail</code> dello smartphone, che contiene sia un client IMAP che POP, ma che \u00e8 chiaramente ottimizzata per un utilizzo con IMAP.</li> <li>l'applicazione desktop <code>Mozilla Thunderbird</code> (https://www.thunderbird.net/) che ovviamente contiene sia un client IMAP che POP.</li> </ul> <p>Buon divertimento!</p> <p> </p>"},{"location":"MAIL/lab_telnet_mail/","title":"Telnet e Mail","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: OS, terminale</p> <p>Argomenti trattati: Telnet, SMTP, POP, IMAP</p>"},{"location":"MAIL/lab_telnet_mail/#introduzione","title":"Introduzione","text":"<p>Telnet \u00e8 un piccolo client da terminale, disponibile su ogni sistema operativo, che serve per simulare connessioni in chiaro a qualsiasi socket desideriamo. La sua utilit\u00e0 sta nel fatto che permette di dialogare con qualunque protocollo del livello superiore che utilizza testo semplice per le sua sintassi.</p> <p>A pensarci bene, tutti i protocolli del livello superiore che abbiamo studiato (o che studieremo) utilizzano dati codificati in ASCII, quindi... telnet pu\u00f2 essere un semplice strumento per provare ad analizzarli!</p> <p>La sua sintassi \u00e8 semplicissima:</p> <pre><code>$ telnet HOST PORT\n</code></pre> <p>Da dopo l'avvenuta connessione bisogna scrivere.. nella lingua del servizio con cui vogliamo dialogare, ovvero bisogna usare le specifiche del protocollo!</p>"},{"location":"MAIL/lab_telnet_mail/#telnet-e-smtp","title":"Telnet e SMTP","text":"<p>Per estrema semplicit\u00e0 simuler\u00f2 semplicemente una connessione ad un MTA generico, di cui elenco le caratteristiche:</p> <ul> <li>host: scuola.lan</li> <li>porta: 25</li> <li>user1: pippo</li> <li>pass1: attentialcane</li> <li>user2: ciccio</li> <li>pass2: pescegatto</li> </ul> <p>Tramite telnet l'utente pippo prover\u00e0 ad inviare una mail all'utente ciccio.</p> <pre><code>$ telnet scuola.lan 25\n\n... risposta ...\n\nHELO pippo\n\n... risposta ...\n\nMAIL FROM: pippo@scuola.lan\n\n... risposta ...\n\nRCPT TO: ciccio@scuola.lan\n\n... risposta ...\n\nDATA\n\n... risposta ...\n\nSubject: Titolo\nUna mail con testo qualsiasi che termina quando\nandate a capo, scrivete un punto e riandate a capo.\n.\n\n... risposta ...\n\nQUIT\n</code></pre> <p>Se avete scritto tutto bene (lo capite osservando le risposte) avete inviato una mail scrivendo a mano le istruzioni SMTP per l'MTA!!! Avete notato che non avete mai inserito la password???</p>"},{"location":"MAIL/lab_telnet_mail/#telnet-e-imap","title":"TELNET e IMAP","text":"<p>Adesso proviamo a consultare la mail dell'utente ciccio per trovare la mail che ha ricevuto. Facciamo prima con IMAP cos\u00ec il messaggio rimane sul server e proviamo successivamente provare con POP ;)</p> <pre><code>$ telnet scuola.lan 143\n\n... risposta ...\n\na1 LOGIN ciccio pescegatto\n\n... risposta ad a1 ...\n\na2 LIST \"\" \"*\"\n\n... risposta ad a2 ...\n\na3 EXAMINE INBOX\n\n... risposta ad a3 ...\n\na4 FETCH 1 BODY[]\n\n... risposta ad a4 ...\n\na5 LOGOUT\n</code></pre> <p>Ecco qua! Avanti...</p>"},{"location":"MAIL/lab_telnet_mail/#telnet-e-pop3","title":"TELNET e POP3","text":"<p>Adesso proviamo a consultare la mail dell'utente ciccio con POP, cancellando il messaggio alla fine della consultazione.</p> <pre><code>$ telnet scuola.lan 110\n\n... risposta ...\n\nUSER ciccio\n\n... risposta ...\n\nPASS pescegatto\n\n... risposta ...\n\nLIST\n\n... risposta ...\n\nRETR 1\n\n... risposta ...\n\nDELE 1\n\n... risposta ...\n\nQUIT\n</code></pre> <p>Come avete intuito leggendo i comandi, vi siete connessi al server POP con le credenziali di ciccio, avete elencato i suoi messaggi, avete letto (e poi cancellato) il messaggio numero 1.</p> <p> </p>"},{"location":"MAIL/py_smtplib/","title":"smtplib","text":""},{"location":"reti/IndirizzamentoIPv4/","title":"Indirizzamento IPv4","text":"<p>Gli indirizzi IP sono numeri che identificano univocamente un dispositivo di rete. Sono organizzati in blocchi di 32 bit e tradotti convenzionalmente nella notazione decimale puntata: questo significa che ogni indirizzo verr\u00e0 trascritto come una sequenza di quattro numeri decimali compresi fra 0 e 255 e separati da punti.</p> <p>Un indirizzo potrebbe essere <code>11000000.10101000.00000000.00000001</code>, che \u00e9 un numero binario a 32 bit, ma per rappresentarlo lo si divide in byte (gruppi di otto) e li si trasforma in decimale.  La rappresentazione <code>192.168.0.1</code> (che \u00e8 identica alla precedente) risulta a noi molto pi\u00f9 chiara e leggibile.</p> Rappresentazione decimale puntata<pre><code>11000000 10101000 00000000 00000001\n     192      168        0        1\n</code></pre> <p>Ogni indirizzo \u00e8 solitamente suddivisibile in due parti: la parte di rete (network) e la parte di host (host). </p> <p>La suddivisione logica insita nell'indirizzamento IPv4 implica dunque una organizzazione fisica</p> <p>Quando 2 dispositivi nella Rete hanno la stessa parte di rete, significa che sono fisicamente connessi allo stesso dispositivo di rete. Vale anche il viceversa! Quando 2 dispositivi sono fisicamente connessi, devono avere indirizzi con identica parte di rete</p> <p>Vedremo successivamente come questa importante caratteristica di IPv4 sia in effetti anche il suo limite pi\u00f9 grande.</p> <p>L'insieme degli indirizzi \u00e8 suddiviso in 5 gruppi definiti \u201c classi \u201d (A, B, C, D, E): </p> <ul> <li>Classe A: indirizzi assegnabili a dispositivi in reti di grandi dimensioni</li> <li>Classe B: indirizzi assegnabili a dispositivi in reti di medie dimensioni</li> <li>Classe C: indirizzi assegnabili a dispositivi in reti di piccole dimensioni</li> <li>Classe D: indirizzi riservati al multicasting</li> <li>Classe E: indirizzi riservati per usi sperimentali</li> </ul> <p>Suggerimento</p> <p>In teoria delle reti, quando un indirizzo \u00e8 assegnabile ad un host viene definito un indirizzo <code>valido</code>. Nell'indirizzamento IPv4 solo gli indirizzi delle classi A,B,C contengono indirizzi validi.</p> <p>Dal punto di vista della composizione degli indirizzi in bit, le varie classi si distinguono dai primi bit di ogni indirizzo:</p> <p></p> <p>Se invece vogliamo studiare le classi guardando la loro rappresentazione decimale, valutando il numero di reti e di dispositivi ammissibili per ogni rete, abbiamo:</p> <p></p>"},{"location":"reti/IndirizzamentoIPv4/#network-address","title":"Network Address","text":"<p>Si definisce network address (indirizzo di rete) quell'indirizzo che si calcola a partire da un qualunque indirizzo IP (anche se ha realmente senso solo per quelli di classe A, B, C) mettendo a zero tutti i bit della parte di host.</p> <p>L'indirizzo di rete \u00e8 un concetto analogo al cognome delle persone: definisce l'appartenenza ad una gruppo. Tutte le stazioni sullo stesso segmento di rete devono avere lo stesso indirizzo di rete , cio\u00e8 i bit di rete dei due indirizzi devono coincidere.</p> <p>Questo ci fa capire che gli indirizzi di rete (gli indirizzi con parte di host nulla) non possono essere assegnati a dei singoli host, ma sono utilizzati per identificare le reti di appartenenza di questi.</p> <p>Ecco alcuni esempi di indirizzi di rete:</p> <ul> <li> <p>Dato l'indirizzo <code>15.0.1.2</code>, che appartiene alla classe A, l'indirizzo di rete a cui appartiene si identificher\u00e0 mettendo a zero la parte di host, ottenendo quindi l'indirizzo <code>15.0.0.0</code>.</p> </li> <li> <p>L'indirizzo <code>15.100.4.73</code> ha la stessa parte di rete del precedente (<code>15.0.0.0</code>). Questo ci fa capire che entrambi gli indirizzi appartengono alla stessa rete fisica.</p> </li> <li> <p>L'indirizzo di classe A <code>100.102.103.104</code> ha indirizzo di rete <code>100.0.0.0</code>, quindi non appartiene alla stessa rete dei due precedenti.</p> </li> <li> <p>L'indirizzo di classe B <code>130.159.200.45</code> appartiene alla rete <code>130.159.0.0</code>.</p> </li> </ul>"},{"location":"reti/IndirizzamentoIPv4/#broadcast-address","title":"Broadcast Address","text":"<p>In analogia al Network Address, nelle reti troviamo un altro indirizzo speciale, il Broadcast Address.</p> <p>Si definisce broadcast address (indirizzo di broadcast) quell'indirizzo che si calcola a partire da un qualunque indirizzo IP (anche se ha realmente senso solo per quelli di classe A, B, C) mettendo a uno tutti i bit della parte di host. </p> <p>L'indirizzo di broadcast per una rete \u00e8 un altro indirizzo speciale che non \u00e8 assegnabile ad alcun dispositivo singolo.  Viene utilizzato per comunicare contemporaneamente con tutti i dispositivi appartenenti alla rete.</p> <p>Vediamo alcuni esempi:</p> <ul> <li> <p>Dato l'indirizzo <code>15.0.1.2</code>, che appartiene alla classe A, l'indirizzo di broadcast della sua rete sar\u00e0 l'indirizzo <code>15.255.255.255</code>.</p> </li> <li> <p>L'indirizzo di classe A <code>100.102.103.104</code> ha indirizzo di broadcast <code>100.255.255.255</code>.</p> </li> <li> <p>L'indirizzo di classe B <code>130.159.200.45</code> ha indirizzo di broadcast <code>130.159.255.255</code>.</p> </li> <li> <p>L'indirizzo di classe C <code>200.199.198.197</code> ha indirizzo di broadcast <code>200.199.198.255</code>.</p> </li> </ul>"},{"location":"reti/IndirizzamentoIPv4/#subnet-mask","title":"Subnet mask","text":"<p>Per meglio distinguere la parte di rete dalla parte di host in un indirizzo, si utilizza la tecnica della subnet mask (maschera di sottorete). </p> <p>La subnet mask \u00e9 una sequenza di 32 bit che contiene prima una sequenza di 1 e poi una sequenza di 0.  Il numero di 1 sta ad indicare il numero di bit riservati alla parte di rete e analogamente il numero di 0 quelli riservati per la parte di host.</p> <p>Anche qui utilizzando la notazione decimale puntata abbiamo le seguenti maschere predefinite:</p> <pre><code>Subnet mask per la Classe A = 255.  0.  0.  0\nSubnet mask per la Classe B = 255.255.  0.  0\nSubnet mask per la Classe C = 255.255.255.  0\n</code></pre> <p>I dispositivi di rete con questa nuova informazione hanno solo necessit\u00e0 di compiere un and logico bit a bit fra indirizzo IP e subnet mask  per calcolare la rete di provenienza o di destinazione di un pacchetto.</p> <p>Esempio</p> <p>Indirizzo: <code>192.168.0.1 / 255.255.255.0</code></p> <p>Se scriviamo i due indirizzi in binario, otteniamo:</p> <pre><code>1 1 0 0 0 0 0 0. 1 0 1 0 1 0 0 0. 0 0 0 0 0 0 0 0. 0 0 0 0 0 0 0 1   ( 192. 168.   0.  1 )\n1 1 1 1 1 1 1 1. 1 1 1 1 1 1 1 1. 1 1 1 1 1 1 1 1. 0 0 0 0 0 0 0 0   ( 255. 255. 255.  0 )\n------------------------------------------------------------------------------------------\n1 1 0 0 0 0 0 0. 1 0 1 0 1 0 0 0. 0 0 0 0 0 0 0 0. 0 0 0 0 0 0 0 0   ( 192. 168.   0.  0 )\n</code></pre> <p>L'indirizzo di rete <code>192.168.0.1 / 255.255.255.0</code> appartiene alla rete <code>192.168.0.0</code>.</p>"},{"location":"reti/IndirizzamentoIPv4/#notazione-cidr","title":"Notazione CIDR","text":"<p>Per semplificare la scrittura di <code>indirizzo / subnet mask</code> \u00e8 stata inventata la cosiddetta notazione CIDR. Essa si basa sull'ovviet\u00e0 che gli indirizzi IPv4 sono sempre fatti con 32 bit e si dividono tramite la subnet mask in due parti (parte di rete e parte di host). Se ad esempio, assegnassimo 4 bit alla parte di rete, ovviamente (per differenza) la parte di host sarebbe composta da 32 - 4 = 28 bit!!</p> <p>La notazione CIDR indica come subnet mask semplicemente il numero di bit della parte di rete.</p> <pre><code>Subnet mask per la Classe A in notazione CIDR = 8\nSubnet mask per la Classe B in notazione CIDR = 16\nSubnet mask per la Classe C in notazione CIDR = 24\n</code></pre> <p>Esempi</p> <ul> <li>indirizzo 1.2.3.4 / 8</li> <li>indirizzo 150.151.152.153 / 16</li> <li>indirizzo 200.201.202.203 / 24</li> </ul>"},{"location":"reti/IndirizzamentoIPv4/#indirizzi-speciali","title":"Indirizzi speciali","text":"<p>TODO: completa con https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml</p> <p>L\u2019indirizzo di rete <code>127</code> \u00e8 riservato per funzioni di loopback , cio\u00e8 i pacchetti spediti a quell\u2019indirizzo vengono trattati come pacchetti in arrivo sulla NIC (Network Interface Card, la scheda di rete) anche se non l\u2019hanno mai lasciata.</p> <p>L\u2019indirizzo <code>127.0.0.1</code> rappresenta il localhost cio\u00e8 la propria stazione di lavoro.</p> <p>Abbiamo inoltre gli indirizzi speciali sotto indicati che consentono le operazioni annesse senza conoscere il reale indirizzo di rete:</p> <ul> <li><code>0.0.0.0</code> indica la stazione corrente, quindi identifica il dispositivo nella rete (no loopback) senza     conoscere realmente il suo indirizzo.</li> <li><code>255.255.255.255</code> indica il broadcast per la rete corrente (qualunque essa sia). Questo indirizzo \u00e8     quello utilizzato ad esempio dai client DHCP per richiedere le informazioni di rete senza sapere     realmente in quale rete si trovino.</li> </ul>"},{"location":"reti/IndirizzamentoIPv4/#indirizzi-ip-privati","title":"Indirizzi IP privati","text":"<p>Gli indirizzi IP sono identificatori univoci a livello mondiale: quindi su Internet ad esempio, non troveremo mai due dispositivi associati allo stesso indirizzo (di classe A, B, C).</p> <p>Una rete locale non collegata al mondo esterno fa mondo a s\u00e9 e quindi su di essa potremo trovare indirizzi che ritroviamo associati in un\u2019altra rete locale isolata, oppure in una (sola) rete collegata ad Internet.</p> <p>Per meglio affrontare il problema delle reti locali isolate (ad esempio le aziende, le banche e perfino le scuole ne hanno ormai una) si \u00e8 pensato di riservare dei gruppi di indirizzi per classe destinati solo ad usi locali. Questi gruppi sono:</p> <pre><code>Classe A La rete 10.0.0.0\nClasse B Le 16 reti da 172.16.0.0 a 172.31.0.0\nClasse C Le 256 reti da 192.168.0.0 a 192.168.255.0\n</code></pre>"},{"location":"reti/IndirizzamentoIPv4/#esercizi-su-ipv4","title":"Esercizi su IPv4","text":"<p>Sia dato il seguente elenco di indirizzi IPv4:</p> <pre><code>- 10. 20. 30. 40\n\n- 50. 100. 150. 200\n\n- 0. 100. 200. 300\n\n- 200. 205. 215. 0\n\n- 172. 20. 37. 4\n</code></pre> <p>Esercizio 1</p> <p>Spiegare quale di quelli non rappresenta un indirizzo IPv4 ben formato.</p> <p>Esercizio 2</p> <p>Per ognuno degli indirizzi della lista, specificare a quale classe di indirizzi appartiene e individuare la parte di rete e la parte di host</p> <p>Esercizio 3</p> <p>Quali, fra gli IP dell\u2019elenco, sono indirizzi validi, ovvero assegnabili a dispositivi? Motivare la risposta.</p> <p>Esercizio 4</p> <p>Per ognuno degli indirizzi validi, individuati nell\u2019esercizio precedente, scrivere il network address di appartenenza e il rispettivo broadcast address</p> <p>Esercizio 5</p> <p>Quali, fra gli IP dell\u2019elenco, sono indirizzi privati, ovvero tali che non sia possibile incontrarli nella rete Internet? Spiegare.</p> <p> </p>"},{"location":"reti/lab_ifconfig_ip/","title":"ifconfig, ip","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Argomenti trattati: Indirizzamento IP</p> <p>Prerequisti: Linux, MacOS: terminale</p> <p>Nell'esperienza ipconfig abbiamo visto come \u00e8 possibile reperire informazioni sulla configurazione di rete in un terminale Windows.</p> <p>In questa esperienza faremo lo stesso nel caso dei terminali Linux e Mac. Ovviamente tutte le considerazioni qui fatte funzionano anche su Raspberry.</p> <p>Nella mia disamina ho deciso di spiegare le cose 2 volte, prima con il comando ifconfig e poi con il comando ip. La scelta di raddoppiare il lavoro dipende da una serie di considerazioni che vado ad elencare:</p> <ul> <li><code>ifconfig</code> \u00e8 un utility pi\u00f9 limitata rispetto alla pi\u00f9 moderna <code>ip</code></li> <li>Non sono sicuro che il comando <code>ip</code> sia disponibile su Mac (probabilmente s\u00ec...)</li> <li>In molte distribuzioni Linux potreste non trovare pi\u00f9 il (vecchio) comando <code>ifconfig</code></li> <li><code>ifconfig</code> \u00e8 pi\u00f9 vecchia e limitata ma pi\u00f9 semplice</li> <li><code>ip</code> \u00e8 in grado di gestire praticamente tutte le configurazioni del livello di rete e inferiore, ma questo implica un diverso grado di complessit\u00e0</li> </ul> <p>Mettendo insieme tutti questi statements ho deciso di introdurre entrambi i tools. Vediamoli.</p> <p>Nelle due trattazioni che seguono cercher\u00f2 di dedurre la configurazione di rete di un generico dispositivo che ha una scheda di rete con cavo, chiamata eth0 e una scheda di rete wifi chiamata wlan0. Potrebbe essere un portatile, oppure un Raspberry, etc... Indico qua le informazioni in modo tale che sia pi\u00f9 semplice capire il funzionamento dei tool di rete, conoscendo in anticipo l'output che cerchiamo.</p> Descrizione Valore Rete 10.0.0.0 Subnet mask 255.255.255.0 broadcast 10.255.255.255 Gateway 10.0.0.1 Server DNS 10.0.0.2 Server DHCP 10.0.0.3 IP scheda con cavo 10.0.0.51 IP scheda wifi 10.0.0.52"},{"location":"reti/lab_ifconfig_ip/#ifconfig","title":"ifconfig","text":"<p>Visualizzare informazioni sulle interfacce di rete</p> <pre><code>$ ifconfig\n\neth0:   flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 10.0.0.51  netmask 255.0.0.0  broadcast 10.255.255.255\n        ether 54:53:ed:XX:XX:XX  txqueuelen 1000  (Ethernet)\n        RX packets 95414  bytes 130702336 (124.6 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 43485  bytes 4338669 (4.1 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 4  bytes 240 (240.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 4  bytes 240 (240.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nwlan0:  flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 10.0.0.52  netmask 255.0.0.0  broadcast 10.255.255.255\n        ether b8:76:3f:YY:YY:YY  txqueuelen 1000  (Ethernet)\n        RX packets 7035  bytes 1837515 (1.7 MiB)\n        RX errors 0  dropped 1496  overruns 0  frame 0\n        TX packets 377  bytes 33009 (32.2 KiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> <p>Imopostare un indirizzo (o cancellarlo) per una interfaccia di rete</p> <pre><code>$ sudo ifconfig eth0 add 192.168.0.51\n$ sudo ifconfig eth0 del 192.168.0.51\n</code></pre> <p>Abilitare o disabilitare una interfaccia di rete</p> <pre><code>$ sudo ifconfig wlan0 up\n$ sudo ifconfig wlan0 down\n</code></pre> <p>Visualizzare la tabella di routing (verificando il gateway predefinito). Con ifconfig non si pu\u00f2 fare. In questo caso bisogna ricorrere al comando route:</p> <pre><code>$ route -n4\n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.0.1        0.0.0.0         UG    100    0        0 eth0\n0.0.0.0         10.0.0.1        0.0.0.0         UG    600    0        0 wlan0\n10.0.0.0        0.0.0.0         255.0.0.0       U     100    0        0 eth0\n10.0.0.0        0.0.0.0         255.0.0.0       U     600    0        0 wlan0\n</code></pre> <p>Impostare il default gateway (oppure in caso di routing pi\u00f9 complessi, aggiungere una route). Oppure rimuoverlo. Ancora tramite l'utility route:</p> <pre><code>$ sudo route add default gw 192.168.0.1 eth0\n$ sudo route del default gw 192.168.0.1 eth0\n</code></pre> <p>Visualizzare i server DNS in uso. Ancora una volta non si usano opzioni del comando ifconfig ma si pu\u00f2 controllare direttamente sul file ove sono scritti:</p> <pre><code>$ cat /etc/resolv.conf\n\nnameserver 10.0.0.2\n</code></pre>"},{"location":"reti/lab_ifconfig_ip/#ip","title":"ip","text":"<p>Visualizzare informazioni sulle interfacce di rete</p> <pre><code>$ ip a\n\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n    valid_lft forever preferred_lft forever\n2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 54:53:ed:XX:XX:XX brd ff:ff:ff:ff:ff:ff\n    inet 10.0.0.51/8 brd 10.255.255.255 scope global dynamic noprefixroute eth0\n    valid_lft 80942sec preferred_lft 80942sec\n3: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether b8:76:3f:YY:YY:YY brd ff:ff:ff:ff:ff:ff\n    inet 10.0.0.52/8 brd 10.255.255.255 scope global dynamic noprefixroute wlan0\n    valid_lft 80939sec preferred_lft 80939sec\n</code></pre> <p>Imopostare un indirizzo (o cancellarlo) per una interfaccia di rete</p> <pre><code>$ sudo ip a add 192.168.0.51 dev eth0    \n$ sudo ip a del 192.168.0.51 dev eth0\n</code></pre> <p>Abilitare o disabilitare una interfaccia di rete</p> <pre><code>$ sudo ip link set wlan0 up\n$ sudo ip link set wlan0 down\n</code></pre> <p>Visualizzare la tabella di routing (verificando il gateway predefinito).</p> <pre><code>$ ip r\n\ndefault via 10.0.0.1 dev eth0 proto dhcp metric 100 \ndefault via 10.0.0.1 dev wlan0 proto dhcp metric 600 \n10.0.0.0/8 dev eth0 proto kernel scope link src 10.0.0.51 metric 100 \n10.0.0.0/8 dev wlan0 proto kernel scope link src 10.0.0.52 metric 600\n</code></pre> <p>Impostare il default gateway (oppure in caso di routing pi\u00f9 complessi, aggiungere una route). Oppure rimuoverlo.</p> <pre><code>$ sudo ip r add 192.168.0.0/24 via 192.168.0.1 dev eth0\n$ sudo ip r del 192.168.0.0/24\n</code></pre> <p>Visualizzare i server DNS in uso. Qui anche l'utility <code>ip</code> non pu\u00f2 arrivare perch\u00e9 il sistema di risoluzione degli indirizzi \u00e8 uno strumento del livello superiore. Il consiglio \u00e8 ancora una volta di controllare il file di configurazione:</p> <pre><code>$ cat /etc/resolv.conf\n\nnameserver 10.0.0.2\n</code></pre> <p> </p>"},{"location":"reti/lab_ipconfig/","title":"ipconfig","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Argomenti trattati: Indirizzamento IP</p> <p>Prerequisti: Windows: command prompt</p> <p><code>Ipconfig</code> \u00e8 il comando basilare fra i vari tool di rete presenti sui sistemi Microsoft,  perch\u00e9 \u00e8 quello che permette di verificare la configurazione delle interfacce di rete presenti nel dispositivo.</p> <p>\u00c8 utilizzabile dal prompt dei comandi per due ordini di motivi: </p> <ul> <li>la diagnostica ovvero il controllo delle configurazioni di rete attualmente impostate (IP, subnet, gateway, DNS, MAC, TTL DHCP, etc...).</li> <li>il reset delle impostazioni, la invocazione del client DHCP, la pulizia della cache DNS, etc...</li> </ul> <p>Vediamo la sintassi generale:</p> <pre><code>$ ipconfig [opzioni] [interfaccia]\n</code></pre> <p>E le opzioni degne di nota:</p> Opzione Significato /all Visualizza le informazioni complete su tutte le NIC installate nel sistema /release Rilascia la configurazione di rete della NIC specificata /renew Rinnova la configurazione di rete della NIC specificata /flushdns Ripulisce la cache DNS /registerdns Aggiorna i lease DHCP e registra i nomi DNS <p>Vediamo un esecuzione del comando ipconfig senza alcuna opzione.</p> <p></p> <p>Come si vede, tramite questo comando \u00e8 possibile visualizzare le informazioni di base di configurazione della rete.  Per accedere a informazioni pi\u00f9 dettagliate dobbiamo utilizzare l'opzione <code>/all</code>:</p> <p></p> <p>Le altre 4 opzioni vanno a coppia e per l'esecuzione richiedono privilegi amministrativi.</p> <p><code>release</code> e <code>renew</code> servono rispettivamente per cancellare le impostazioni di rete ottenute  dal server DHCP e per richiedere allo stesso di inviarne di nuove.  Pu\u00f2 essere utile in alcune situazioni se la connettivit\u00e0 \u00e8 limitata perch\u00e9 il pacchetto di risposta DHCP \u00e8 arrivato incompleto o corrotto.</p> <pre><code>$ ipconfig /release\n\n... attendi qualche secondo...\n\n$ ipconfig /renew\n</code></pre> <p>La seconda coppia di opzioni pu\u00f2 essere utile quando qualche dispositivo di rete ha cambiato nome e si ha necessit\u00e0 di riaggiornare le informazioni senza aspettare la scadenza naturale delle stesse tramite il TTL.</p> <pre><code>$ ipconfig /flushdns\n\n... attendi qualche secondo...\n\n$ ipconfig /registerdns\n</code></pre> <p>Ecco tutto!  Adesso siete dei mezzi draghi del comando <code>ipconfig</code>!!! </p> <p> </p>"},{"location":"reti/py_ipaddress/","title":"ipaddress","text":"<p>IPv4 vs IPv6</p> <p>Il modulo <code>ipaddress</code> gestisce perfettamente sia l'indirizzamento IPv4 che quello basato su IPv6.  Per semplicit\u00e0, in questa trattazione ci concentreremo solo sull'indirizzamento IPv4.</p> <p>Il modulo <code>ipaddress</code> \u00e8 un modulo per la gestione e la manipolazione degli indirizzi IP (IPv4/IPv6). Per poter utilizzare il modulo \u00e8 necessario istanziare un oggetto della classe, un indirizzo.</p> <p>Questo pu\u00f2 essere fatto per valore:</p> <pre><code>&gt;&gt;&gt; # indirizzo inserito tramite notazione decimale puntata\n&gt;&gt;&gt; a = ipaddress.ip_address('192.0.2.1')\nIPv4Address('192.0.2.1')\n\n&gt;&gt;&gt; # indirizzo inserito in forma numerica (int)\n&gt;&gt;&gt; b = ipaddress.ip_address(3221225985)\nIPv4Address('192.0.2.1')\n</code></pre> <p>Come per gli indirizzi, \u00e8 possibile definire una rete di indirizzi (tramite un network address):</p> <pre><code>&gt;&gt;&gt; # definizione tramite notazione decimale puntata pi\u00f9 network mask in notazione CIDR\n&gt;&gt;&gt; net1 = ipaddress.ip_network('192.0.2.0/24')\nIPv4Network('192.0.2.0/24')\n</code></pre> <p>Se inserisci un ip che non \u00e8 un network address, la funzione <code>ip_network</code> da giustamente errore. Per\u00f2 se sei somaro sui network address, ma ci capisci di Python,  \u00e8 possibile ottenere un indirizzo di rete a partire da qualunque indirizzo IP, tramite l'opzione <code>strict=False</code>:</p> <pre><code>&gt;&gt;&gt; # se sbagli il network address, ip_network da errore\n&gt;&gt;&gt; net2 = ipaddress.ip_network('192.0.2.1/24')\nValueError: 192.0.2.1/24 has host bits set\n\n&gt;&gt;&gt; # se invece usi l'opzione strict=False, Python se la calcola da solo a partire da qualunque indirizzo IP\n&gt;&gt;&gt; net3 = ipaddress.ip_network('192.0.2.1/24', strict=False)\nIPv4Network('192.0.2.0/24')\n</code></pre> <p>Come per gli indirizzi, \u00e8 possibile utilizzare i numeri interi anche per la definizione delle reti:</p> <pre><code>&gt;&gt;&gt; net4 = ipaddress.ip_network(3221225984)\nIPv4Network('192.0.2.0/32')\n</code></pre> <p>Se vuoi indicare un IP indicando esplicitamente la maschera di sottorete, devi usare la notazione CIDR e la funzione <code>ip_interface</code>. A partire da questa... puoi fare parecchie cosine con l'oggetto indirizzo:</p> <pre><code>&gt;&gt;&gt; host1 = ipaddress.ip_interface('192.0.2.1/24')\nIPv4Interface('192.0.2.1/24')\n&gt;&gt;&gt; net1 = host1.network\nIPv4Network('192.0.2.0/24')\n</code></pre> <p>Anche con le reti, \u00e8 possibile fare parecchie cose in maniera abbastanza semplice:</p> <pre><code>&gt;&gt;&gt; net4 = ipaddress.ip_network('192.0.2.0/24')\n&gt;&gt;&gt; net4.num_addresses\n256\n&gt;&gt;&gt; for x in net4.hosts():\n        print(x)  \n192.0.2.1\n192.0.2.2\n192.0.2.3\n192.0.2.4\n...\n192.0.2.252\n192.0.2.253\n192.0.2.254\n&gt;&gt;&gt; mask = net4.netmask\nIPv4Address('255.255.255.0')\n</code></pre> <p>Gli oggetti di tipo network possono essere trattate anche come liste:</p> <pre><code>&gt;&gt;&gt; net4[1]\nIPv4Address('192.0.2.1')\n\n&gt;&gt;&gt; net4[25]\nIPv4Address('192.0.2.25')\n\n&gt;&gt;&gt; net4[-1]\nIPv4Address('192.0.2.255')\n</code></pre> <p> </p>"},{"location":"reti/subnetting/","title":"Subnetting","text":"<p>La tecnica di organizzazione degli indirizzi in classi \u00e8 divenuta limitante nel momento in cui il numero di indirizzi assegnati \u00e8 iniziato velocemente a salire. Questo perch\u00e9 l'assegnazione per classi degli indirizzi tende per costruzione a sprecarne una grande quantit\u00e0: infatti vi ricordo che la caratteristica principale di IPv4 \u00e8 quella di aggregare fisicamente tutti i dispositivi che dal punto di vista logico sono aggregati, ovvero che hanno la stessa parte di rete.</p> <p>Proviamo a spiegare la questione.</p> <p>Gli indirizzi IP mondiali sono gestiti da un unico ente centrale: ICANN (Internet Corporation for Assigned Names and Numbers).  Questi vengono distribuiti ai provider di servizi internet per reti, cio\u00e8 ogni provider pu\u00f2 richiedere una rete di indirizzi IP,  di cui rivendere gli indirizzi IP validi e poi, una volta terminati, richiederne una nuova.</p> <p>Internet Service Providers</p> <p>Gli ISP, acronimo per Internet Service Providers, ovvero fornitori di servizi internet sono quelle societ\u00e0 che forniscono connettivit\u00e0 ai privati.</p> <p>In Italia le pi\u00f9 famose sono TIM, Vodafone, Fastweb, Iliad, etc...</p> <p>Ogni provider ovviamente gestisce la sua propria rete fisica e quindi necessita di un indirizzamento separato dagli altri.</p> <p>Capito a grandi linee il funzionamento dell'indirizzamento su Internet, proviamo con un esempio a spiegare come IPv4 sia, per sua stessa natura, una fonte di spreco per l'utilizzo degli indirizzi IP.</p> <p>Ad esempio, al provider (di fantasia) PUNTO.IT, che lavora in Italia, viene assegnata da ICANN la rete di classe B di indirizzo <code>150.60.0.0</code> (max 65534 host).  Se il volume di affari di PUNTO.IT si attesta (ad esempio) in 30 mila utenti, esso star\u00e0 sprecando pi\u00f9 di 34 mila indirizzi che non possono essere assegnati a  nessun altro!!!</p> <p>Il subnetting \u00e8 una tecnica che si prefigge di mitigare il problema dello spreco di indirizzi IPv4, quando il problema \u00e8 casuato dalla natura stessa di IPv4 (problema della frammentazione delle reti).</p> <p>Il subnetting \u00e8 una tecnica migliorativa per IPv4 (una vera genialata, secondo me).  Si incastra perfettamente nella sua organizzazione per classi senza stravolgere la logica di base di IPv4.</p> <p>La tecnica del subnetting divide una rete in N sottoreti (dove N \u00e8 una potenza di 2).</p> <p>Ad esempio, nel caso di PUNTO.IT precedentemente illustrato, dividendo la rete in 2 parti (da 32 mila indirizzi ciascuna), il problema dello spreco di indirizzi sarebbe praticamente annullato: PUNTO.IT avrebbe gli IP a lui necessari (con 2000 host circa disponibili per \u201cmigliorare\u201d il suo mercato) e il secondo gruppo sarebbe riassegnabile ad un altro provider (ad esempio DOT.COM) per il suo mercato.</p> <p>Proviamo a scrivere i dati del problema per rendere evidente la tecnica:</p> <p>Rete iniziale affidata alla societ\u00e0 \"PuntoIt\": <code>150.60.0.0 / 16</code></p> <p>Se come abbiamo detto, vogliamo dividere la rete in due sottoreti, dovremo rubare alcuni bit dalla parte di host e spostarli nella parte di rete, ad indicare la parte di sottorete. </p> <p>Ma quanti bit? </p> <p>Questo dipende chiaramente da quante sottoreti vogliamo fare. Per fare due sottoreti prendere un bit: la prima sottorete avr\u00e0 il bit di sottorete a 0,  la seconda il bit di sottorete a 1.</p> <p>Dove lo prendiamo questo bit?</p> <p>L'ho gi\u00e0 detto... dalla parte di host!</p> <p>S\u00ec... ma quale prendiamo??</p> <p>Questa \u00e8 la domanda pi\u00f9 intelligente finora... i bit da prendere sono quelli pi\u00f9 a sinistra, in modo da ottenere una suddivisione comunque compatta fra parte di rete e parte di host. Quindi:</p> <ul> <li>la prima sottorete avr\u00e0 parte di rete <code>150. 60</code> e il bit seguente ZERO.</li> <li>la seconda sottorete avr\u00e0 parte di rete <code>150. 60</code> e il bit seguente UNO.</li> </ul> <p>A questo punto i bit di rete diventano <code>16 + 1 = 17</code> !!!</p> <pre><code>Prima sottorete :   150. 60. 00000000. 0 / 17\n\nSeconda sottorete:  150. 60. 10000000. 0 / 17\n</code></pre> <p>Da qui, applicando le solite regole (tutti i bit di host a ZERO per il network address, tutti a UNO per il broadcast address...) si ottengono i seguenti IP:</p> <p>Prima sottorete</p> <p>subnetwork address:      150. 60. 0. 0 / 17  primo indirizzo valido:  150. 60. 0. 1 / 17  ... ultimo indirizzo valido: 150. 60. 127. 254 / 17 Broadcast address:       150. 60. 127. 255 / 17</p> <p></p> <p>Seconda sottorete</p> <p>subnetwork address:      150. 60. 128. 0 / 17 primo indirizzo valido:  150. 60. 128. 1 / 17 ... ultimo indirizzo valido: 150. 60. 255. 254 / 17 Broadcast address:       150. 60. 255. 255 / 17</p> <p>Suggerimento</p> <p>Quando facciamo un subnetting ricordiamoci di indicare sempre la subnet mask di riferimento!</p> <p>La notazione CIDR \u00e8 stata inventata appositamente per il subnetting... usiamo sempre quella!</p>"},{"location":"reti/subnetting/#esercizi-sul-subnetting","title":"Esercizi sul subnetting","text":"<p>Esercizio 101</p> <p>Eseguire il subnetting della rete con network address di classe B 150. 40. 0. 0, cercando di ottenere almeno 6 sottoreti.</p> <p>Elencare:</p> <ul> <li>il numero di bit da prestare alla parte di rete</li> <li>il numero di sottoreti create e il numero di host ottenuti per sottorete</li> <li>il network address, il primo indirizzo valido, l'ultimo indirizzo valido e il broadcast address     della terza sottorete</li> </ul> <p>Esercizio 102</p> <p>Eseguire il subnetting della rete con network address di classe B 150. 40. 0. 0, facendo in modo che in ogni sottorete ci siano almeno 1000 host.</p> <p>Elencare:</p> <ul> <li>il numero di bit da prestare alla parte di rete</li> <li>il numero di sottoreti create e il numero di host ottenuti per sottorete</li> <li>il network address, il primo indirizzo valido, l'ultimo indirizzo valido e il broadcast address     della seconda sottorete</li> </ul> <p>Esercizio 103</p> <p>Si prenda in considerazione una divisione di sottorete per una organizzazione dotata di una rete di indirizzi di classe B (ad esempio, la classe 180. 40. 0. 0 / 16) che dovr\u00e0 contenere almeno 76 sottoreti. Quanti host potranno esserci su ciascuna sottorete?</p> <p>Esercizio 104</p> <p>Una organizzazione ha deciso di dividere il proprio network address di classe B, sfruttando il terzo ottetto per le reti fisiche, ma si \u00e8 accorta di non aver sufficiente spazio per ospitare 255 host in ogni rete. Spiegare.</p> <p>Esercizio 105</p> <p>Sia data la rete di classe C 192.193.194.0. In quanti modi \u00e8 possibile fare il subnetting su di essa? Elencare i possibili subnetting indicando anche il numero di host per sottorete che si ottengono in ogni caso.</p> <p>Esercizio 106</p> <p>Consideriamo una rete con 25 dispositivi. Calcolare la maschera di sottorete che minimizzi lo spreco di host per rete. Assegnare gli indirizzi ai dispositivi estraendo una opportuna sottorete dall'indirizzo di rete di classe C 193. 212. 100. 0 / 24.</p> <p>Esercizio 107</p> <p>Considerare 2 sottoreti A e B con numero di host A + B = 18. Calcolare la maschera di sottorete che minimizzi lo spreco di indirizzi IP e assegnare ai singoli dispositivi prendendo gli IP dall'indirizzo di rete 193. 200. 10. 0 / 24 in modo che le due sottoreti siano contigue.</p> <p>Esercizio 108</p> <p>Considerare 2 sottoreti A e B connesse da un router R. Il numero di hosts per sottorete \u00e8 rispettivamente 40 e 15. Si ha in gestione l'indirizzo di rete 193. 200. 10. 0 / 24. Assegnare indirizzi alle due sottoreti in maniera contigua e in modo che abbiano lo stessa subnet mask.</p> <p>Esercizio 109</p> <p>L'indirizzo di rete di classe B 142. 8. 0. 0 \u00e8 suddiviso in sottoreti dedicando 6 bit alla subnet e 10 bit agli host. Si specifichi l'indirizzo del terzo host della seconda subnet e gli indirizzi minimo e massimo degli host della quarta subnet. Infine verificare se l'indirizzo 142. 8. 252. 124 \u00e8 un indirizzo corretto e valido (cio\u00e8 assegnabile ad un dispositivo).</p> <p>Esercizio 110</p> <p>Un piccolo numero di indirizzi IP consecutivi sono disponibili partendo da 192. 214. 11. 0. Supponiamo che le organizzazioni A, B, C richiedano rispettivamente 100, 50, 40 indirizzi.</p> <p>Per ognuno di questi specificare:</p> <ul> <li>il primo indirizzo IP assegnato</li> <li>l'ultimo indirizzo IP assegnato</li> <li>l'indirizzo di rete e di broadcast per ogni sottorete</li> </ul> <p>Esercizio 111</p> <p>Si determini il subnetting IP in cui si vogliono creare 62 sottoreti in classe B con indirizzo di partenza 128. 10. 0. 0</p> <ul> <li>determinare la subnet mask</li> <li>determinare il numero di host per sottorete</li> <li>determinare, in una delle sottoreti, indirizzo di rete, intervallo degli indirizzi di host e indirizzo     di broadcast</li> </ul> <p>Esercizio 112</p> <p>Si determini il subnetting IP in cui si vogliono creare 10 sottoreti in classe C con indirizzo di partenza 193. 200. 10. 0 e calcolare:</p> <ul> <li>la subnet mask</li> <li>il numero di host per sottorete</li> <li>in una delle sottoreti, indirizzo di rete, intervallo degli indirizzi di host e indirizzo di broadcast</li> </ul> <p> </p>"},{"location":"routing/ARP/","title":"Protocollo ARP","text":"<p>ARP (Address Resolution Protocol) \u00e8 un protocollo \"storico\" delle reti, implementato nel 1982 tramite l'RFC 826, rappresenta uno strumento indispensabile del protocollo di rete e grazie anche al suo opposto RARP (Reverse ARP) si pone come strumento di collegamento fra il livello di rete e quello inferiore.</p> <p>Per essere spedito infatti, un pacchetto IP deve essere passato al livello inferiore che avr\u00e0 il compito di individuare fisicamente il dispositivo del destinatario e di trasformare in segnali fisici i dati logici contenuti nei pacchetti IP. La procedura di individuazione fisica del destinatario si risolve tramite il protocollo ARP, che \u00e8 in grado di abbinare ad ogni indirizzo logico (un indirizzo IP) un indirizzo fisico (un indirizzo MAC) che identifica univocamente un dispositivo.</p> <p>L'indirizzo MAC, o indirizzo fisico, \u00e8 un identificatore univoco per una scheda di rete. </p> <p>Questo significa che ogni scheda di rete prodotta sulla Terra possiede un indirizzo MAC diverso e che questo permette di tracciare il costruttore, il pezzo prodotto e in molti casi persino l'acquirente (da parte della ditta produttrice).</p> <p>Struttura dell'indirizzo MAC</p> <p>L'indirizzo MAC \u00e9 formato da 6 coppie di cifre esadecimali, indicate di solito con due punti che li separano, ad esempio: 00:C0:9F:3C:C0:20</p> <p>Delle 6 coppie le prime 3 (in questo caso 00:C0:9F) identificano la ditta produttrice, mentre le 3 rimanenti (3C:C0:20) identificano il \"pezzo\" nel lotto di produzione.</p> <p>L'identificazione di un dispositivo tramite indirizzo MAC \u00e8 molto vincolante e pu\u00f2 dunque avvenire solo in una rete locale, infatti ARP manda in broadcast una richiesta del tipo:</p> <pre><code>Who has 192.168.0.13? Tell 192.168.0.10\n</code></pre> <p>Tutti i dispositivi della rete locale riceverano la richiesta ma solo uno avr\u00e0 quell'indirizzo IP e risponder\u00e0 (in unicast, all'indirizzo indicato) con il suo indirizzo MAC</p> <pre><code>192.168.0.13 is at 01:02:03:04:05:06\n</code></pre> <p>A questo punto, colui che ha fatto la richiesta (il dispositivo con indirizzo 192.168.0.10 nel nostro esempio) inserir\u00e0 nella sua cache ARP la coppia indirizzo IP / indirizzo MAC. In questo modo non avr\u00e0 bisogno di richiedere ogni volta l'intervento del protocollo ARP per risolvere un indirizzo.</p> <p>Allo stesso modo per\u00f2, per permettere cambiamenti nella configurazione della rete, ad ogni voce nella cache viene assegnata un <code>TTL (Time To Live)</code>,  un tempo oltre il quale la voce viene cancellata.</p> <p>Il TTL di default dura 2 minuti. Ogni volta che avviene traffico fra le due stazioni il TTL si resetta a 2 minuti. Oltre 10 minuti la voce in cache viene comunque eliminata.</p> <p> </p>"},{"location":"routing/NAT/","title":"NAT","text":"<p>NAT (Network Address Translation), noto anche come *Masquerading \u00e8 una tecnica di rete implementabile nei router che consiste nel modificare gli indirizzi IP contenuti negli header dei pacchetti in transito su di essi.</p> <p>Le due principali tipologie di NAT sono il Source Nat (SNAT) e il Destination NAT (DNAT)</p>"},{"location":"routing/NAT/#source-nat","title":"Source NAT","text":"<p>SNAT viene utilizzato da tutti quei client che si trovano all'interno di una rete privata e hanno bisogno di accedere ad un host pubblico, cosa che non potrebbero fare con il loro IP privato.</p> <p>Esso trasla l'indirizzo IP del mittente (privato) nell'indirizzo IP pubblico del router che opera l'SNAT. Pu\u00f2 modificare con la porta sorgente dell'header TCP/UDP.</p> <p>Tipicamente questa tecnica permette a multipli host all'interno di una rete privata locale di accedere alla rete Internet.</p> <p>Il router che fa SNAT lo esegue dopo che \u00e8 stato deciso il routing.</p>"},{"location":"routing/NAT/#destination-nat","title":"Destination NAT","text":"<p>DNAT viene utilizzato da tutti quei client che si trovano su Internet (hanno un IP pubblico) e hanno bisogno di accedere ad uno specifico host privato, impossibile da raggiungere direttamente con un IP pubblico.</p> <p>Esso trasla l'indirizzo IP del destinatario (pubblico) nell'indirizzo IP privato dell'host che detiene il servizio masquerato dall'IP pubblico. Pu\u00f2 modificare con la porta di destinazione dell'header TCP/UDP (port forwarding).</p> <p>Tipicamente questa tecnica permette di ospitare servizi (ad esempio un sito web) all'interno di una rete privata, rendendoli accessibili dall'esterno.</p> <p>Il router che fa DNAT lo esegue prima di decidere il routing.</p> <p> </p>"},{"location":"routing/lab_arp/","title":"arp","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: Windows: command prompt, Linux, Mac: terminale</p> <p>Argomenti trattati: Protocolli IP, ARP</p> <p>L'utility di rete ARP serve per accedere alla cache arp (appunto) in cui vengono mantenute le informazioni sul neighbourhood del dispositivo, ovvero sui dispositivi contattabili direttamente da esso, senza l'ausilio del gateway predefinito, tramite un invio diretto.</p> <p>Come sappiamo il protocollo ARP funge da strumento di risoluzione degli indirizzi (ARP sta per Address Resolution Protocol) e infatti abbina ogni indirizzo IP contattabile (reachable) nella rete del dispositivo al suo indirizzo MAC.</p> <p>Vediamo la sintassi generale:</p> <pre><code>$ arp [opzioni]\n</code></pre> <p>Le opzioni realmente interessanti sono solo 3 e sono quelle che servono per:</p> <ol> <li>visualizzare la cache ARP,</li> <li>aggiungere una voce alla cache (una coppia IP-MAC)</li> <li>cancellare una voce (o tutte) da essa.</li> </ol> <p>Ovviamente le operazioni di modifica della cache (inserimento e/o cancellazione) richiedono privilegi amministrativi mentre la visualizzazione della stessa \u00e8 sempre abilitata perch\u00e9 qualunque software per accedere alla rete deve poterne usufruire.</p> <p>Vediamo le opzioni:</p> Opzione Significato -a Visualizza la cache ARP -s indirizzo_IP indirizzo_MAC Inserisce la coppia IP:MAC nella cache ARP -d indirizzo_IP Elimina la voce corrispondente a indirizzo_IP dalla cache ARP -d Cancella tutta la cache ARP <p>Come vedete le opzioni sono poche e semplici. Ancora pi\u00f9 semplice se si considera che nel 99% dei casi l'unica che si utilizza \u00e8 quella per visualizzare la cache corrente:</p> <p></p> <p>Esercizio di comprensione</p> <ol> <li>Visualizza la cache ARP del PC nel laboratorio.</li> <li>Prova a pingare un altro dispositivo del laboratorio acceso ma non presente in cache</li> <li>Visualizza di nuovo la cache ARP</li> <li>Prova a pingare un sito web qualsiasi</li> <li>Visualizza di nuovo la cache ARP</li> </ol> <p>Osserva quello che \u00e8 cambiato nelle 3 visualizzazioni e conferma quanto abbiamo studiato.</p> <p> </p>"},{"location":"routing/lab_ping/","title":"ping","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: Windows: command prompt. Linux, Mac: terminale</p> <p>Argomenti trattati: Indirizzamento IP</p> <p>ping \u00e8 un software di diagnostica di rete, implementato in tutti i sistemi operativi, che misura il tempo (in millisecondi) impiegato da uno o pi\u00f9 pacchetti ICMP a raggiungere un altro dispositivo di rete e tornare indietro.</p> <p>Tecnicamente ping invia un pacchetto ICMP di echo request e rimane in attesa di un pacchetto ICMP di echo response in risposta. Solitamente infatti la parte di OS dedicata alla gestione delle reti (stack di rete) \u00e8 impostata per rispondere automaticamente con un pacchetto echo response alla ricezione di un pacchetto di echo request.</p> <p>Il comando ping su Windows \u00e8 impostato per inviare 4 pacchetti ICMP, attendere 4 risposte e poi calcolare le statistiche di ricezione e velocit\u00e0. La sintassi del comando ping \u00e8 la seguente:</p> <pre><code>$ ping [opzioni] host\n</code></pre> <p>Evitiamo di addentrarci nel discorso delle opzioni del comando ping e vediamo semplicemente il funzionamento e l'utilit\u00e0 dello stesso.</p> <p></p> <p>Come si vede, basta scegliere un target host (tramite IP o hostname) e lanciare il comando. Al termine dell'esecuzione bisogna osservare i pacchetti ritornati e le statistiche di viaggio degli stessi per valutare la salute e le performance della rete stessa.</p> <p>Attenzione!</p> <p>Il comando ping su Windows \u00e8 impostato automaticamente ad interrompersi dopo l'invio di 4 pacchetti.</p> <p>In ambienti Linux o Mac invece, il comando ping continua indefinitamente ad inviare pacchetti finch\u00e9 non lo si interrompe con un comando CTRL + C (mela + C su Mac). Quando viene interrotto l'invio vengono generate le statistiche.</p> <p>Il comando ping insieme ai comandi ipconfig e traceroute sono un ottimo strumento di diagnostica e sono semplicissimi da utilizzare. L'importante \u00e8 ragionare sui risultati che si ottengono e formulare deduzioni appropriate.</p> <p>Ping test #1</p> <p>Nel primo test, valutiamo la connettivit\u00e0 della nostra rete. Controllando (con ipconfig/ifconfig/ip a seconda del sistema) abbiamo visto che il nostro IP \u00e8 192.168.0.7 e che il nostro gatweway \u00e8 192.168.0.1.</p> <p>I test da eseguire sono nell'ordine i seguenti</p> <pre><code># ping al nostro indirizzo\n# se risponde significa che la scheda \u00e8 attiva e funzionante\n$ ping 192.168.0.7\n\n# ping al nostro gatweway\n# se risponde significa che la nostra rete \u00e8 attiva e funzionante\n$ ping 192.168.0.1\n\n# ping ad un IP esterno\n# se risponde significa che abbiamo connettivit\u00e0 Internet\n$ ping 1.1.1.1\n\n# ping ad un host\n# se risponde significa che anche la risoluzione DNS funziona!\n$ ping google.it\n</code></pre> <p>Se tutti questi test hanno funzionato correttamente, potete stare certi che il vostro dispositivo \u00e8 ben connesso alla rete Internet. In caso negativo, valutando quale test fallisce potete in maniera semplice individuare il problema.</p> <p>Ping test #2</p> <p>Nel secondo test valutiamo la velocit\u00e0 dei server DNS che stiamo utilizzando. Si tratta di risolvere un host tramite una risoluzione DNS manuale e poi valutare la differenza di prestazioni fra il ping con hostname e il ping con IP.</p> <pre><code># risoluzione\n$ nslookup example.com\n1.2.3.4\n\n# ping HOSTNAME\n$ ping example.com\n...\n\n# ping IP\n$ ping 1.2.3.4\n...\n</code></pre> <p>Ovviamente questo test \u00e8 molto empirico e non sempre funziona poich\u00e9 non tutti i dispositivi rispondono ai ping </p> <p>Ping test #3</p> <p>Nel terzo test cercheremo di valutare la velocit\u00e0 della propria rete. L'idea di base \u00e8 questa. Si scelgono 3 siti a caso (ad esempio: youtube.com, quotidiani.net, autoscout24.it) e si fanno i ping ad ognuno di essi. Si osservano i valori scegliendo il pi\u00f9 alto riportato nei tre test e si valuta la rete secondo la seguente tabella:</p> ping time (ms) velocit\u00e0 rete &gt; 0 - 20 Ottima 20 - 40 Buona 40 - 60 Discreta 60 - 80 Sufficiente oltre 80 ... <p>Okkio eh...</p> <p>Questa tabella e questo modo di valutare la velocit\u00e0 di una rete hanno pochissime basi scientifiche e sono solo una stima di massima che io di solito faccio per valutare una rete.</p> <p>La velocit\u00e0 della rete dipende da moltissimi fattori, tra cui: i siti che visitate, l'orario di utilizzo, l'hardware a disposizione, la connessione wifi vs cablata, etc...</p> <p> </p>"},{"location":"routing/lab_traceroute/","title":"traceroute","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: Windows: command prompt. Linux, Mac: terminale</p> <p>Argomenti trattati: Protocolli IP, ICMP. Routing</p> <p>Prima d tutto chiariamoci su una importante banalit\u00e0: il comando che esegue l'operazione di tracerouting ha un nome diverso su Window, su Linux, su Mac. Su Linux e Mac troviamo l'implementazione originale del tool di rete, che si chiama come l'operazione che esegue: traceroute.</p> <p>Su Windows \u00e8 stato progettato un nuovo tool, che si chiama tracert, fa esattamente la stessa cosa del precedente, con una interfaccia testuale sicuramente pi\u00f9 carina e ordinata, al prezzo di ben tre ordini di grandezza (millisecondi contro microsecondi) e di una divergenza dallo standard che depone una volta di pi\u00f9 sulla simpatica politica dell'azienda con le finestre.</p> <p>Allego 2 screenshot (il primo su Windows, il secondo su Linux, su Mac \u00e8 uguale a Linux) dell'esecuzione di un traceroute verso il target 1.1.1.1 (scelto solo per la sua semplicit\u00e0 numerica).</p> <p>Il traceroute utilizza i pacchetti ICMP di tipo, appunto, traceroute per determinare i nodi di rete che il pacchetto attraversa. E verificare dunque i salti che il pacchetto compie per andare dal punto A al punto B.</p> <p></p> <p>Immagine dell'esecuzione di tracert su Windows.</p> <p></p> <p></p> <p>Immagine dell'esecuzione di traceroute su Linux o Mac.</p> <p></p> <p></p> <p>Analizzate i risultati ottenuti per comprendere al meglio il processo di routing dei pacchetti.</p> <p> </p>"},{"location":"routing/network/","title":"Suite Internet: Livello di rete","text":"<p>Il livello di rete della suite Internet si occupa delle seguenti procedure:</p> <ul> <li> <p>l'indirizzamento, ovvero la possibilit\u00e0 di distinguere i dispositivi tra loro e di raggrupparli opportunamente.</p> </li> <li> <p>L'impacchettamento, ovvero la preparazione dei pacchetti adatti ad essere trasferiti nella rete Internet    per andare dal mittente al destinatario (adesso che con l'indirizzamento pu\u00f2 distinguerli).</p> </li> <li> <p>L'instradamento, ovvero la scelta del percorso che un generico pacchetto dati deve compiere per andare dal mittente al destinatario.</p> </li> <li> <p>La gestione delle congestioni, che durante l'instradamento possono verificarsi se troppi pacchetti sono indirizzati verso un   unico percorso di rete, eventualmente troppo trafficato.</p> </li> </ul> <p>Prima di andare avanti, impariamo un minimo di terminologia, che ci torner\u00e0 utile per comprendere appieno i concetti a cui faremo riferimento.</p>"},{"location":"routing/network/#terminologia","title":"Terminologia","text":"<p>host Qualunque dispositivo che accede alla rete tramite un indirizzo IP, grazie al quale pu\u00f2 essere identificato univocamente.</p> <p>routing (instradamento) Scelta del percorso che un pacchetto IP deve compiere.</p> <p>router Software che determina il routing. Poich\u00e9 tipicamente queste operazioni vengono svolte su dispositivi dedicati, il termine indica spesso anche l'apposito dispositivo di rete, in cui \u00e8 stato installato il software per la selezione del percorso dei pacchetti che transitano su di esso.</p> <p>tabella di routing Set di informazioni che permettono al router di stabilire il percorso per ogni pacchetto in transito.</p> <p>Ok, adesso siamo pronti!!!</p>"},{"location":"routing/network/#protocollo-ip","title":"Protocollo IP","text":"<p>Quando si descrive il livello di rete non si pu\u00f2 fare a meno di parlare del protocollo IP! Questo protocollo infatti, interviene in tutte le connessioni (unico protocollo della suite sempre utilizzato) e si occupa di gran parte del lavoro! Pi\u00f9 precisamente si occupa dell'indirizzamento, dell'impacchettamento e della prima fase dell'instradamento!</p> <p>Indirizzamento</p> <p>Dovremmo aver gi\u00e0 studiato l'indirizzamento IP! Quella struttura permette di distinguere tutti i dispositivi che appartengono alla rete Internet!!!</p> <p>Impacchettamento</p> <p>IP \u00e8 l'unico protocollo di rete che fa pacchetti. Questi presentano la caratteristica di essere instradabili, ovvero di essere adatti alle operazioni di routing. Tutti gli altri protocolli di rete intervengono eventualmente dopo IP, utilizzando direttamente i pacchetti IP per le loro operazioni, eventualmente modificando l'intestazione del pacchetto.</p> <p>Routing (primo step)</p> <p>Il protocollo IP si occupa perfino del primo instradamento, ovvero dell'uscita dal dispositivo del mittente tramite la sua logica di base del protocollo IP.</p> <p>Esso confronta l'indirizzo IP del mittente del pacchetto con quello del destinatario e si comporta secondo le seguenti regole:</p> <ul> <li>Se l'indirizzo IP del mittente \u00e8 uguale all'IP del destinatario,     oppure uno degli indirizzi \u00e8 della classe 127, il pacchetto viene     rimbalzato al livello di trasporto (tecnica del loopback).</li> <li>Se il destinatario si trova sullo stesso segmento di rete del     mittente, il pacchetto viene inviato in maniera diretta,     individuando il destinatario tramite ARP (un altro protocollo di     rete, che vedremo fra breve).</li> <li>Se il destinatario NON si trova nella stessa rete del mittente, si     invia il pacchetto al default gateway.</li> </ul> <p>Impacchettato correttamente, inserito in un indirizzamento organizzato e finalmente fuori dal disposirivo mittente, il prossimo compito del livello di rete viene affidato ai protocolli di routing.</p> <p> </p>"},{"location":"routing/routing/","title":"Routing","text":"<p>Se dobbiamo occuparci di routing, significa che siamo gi\u00e0... in viaggio! Infatti il routing, l'instradamento, la scelta del percorso va effettuata per tutti quei pacchetti che secondo la logica di base del protocollo IP sono stati inviati al default gateway, ovvero il primo dispositivo in grado di fare routing e che si occupa di gestire quei pacchetti il cui indirizzo di destinazione appartiene ad una rete diversa da quella dell'indirizzo del mittente.</p> <p>Lasciatemi dire che il routing \u00e8 praticamente quell'arte magica che riesce ad indirizzare ogni pacchetto verso la sua destinazione.</p> <p>Magia, non c'\u00e8 un altro termine. Noi proveremo per\u00f2 a capire il trucco...</p> <p>Intanto diciamo che il routing rappresenta il \"grosso\" del lavoro nel trasferimento di un pacchetto dal mittente A al destinatario B. Per spiegare questo concetto possiamo prendere ad esempio la trasmissione di una lettera. Il mittente la scrive, la indirizza e la spedisce, mettendola in una cassetta della posta. Al massimo il mittente avr\u00e0 dunque contatti col postino incaricato di raccogliere la posta da quella cassetta. Tutto il trasferimento organizzato dalle poste (camion, treno, aereo, etc.) non lo coinvolge assolutamente. Il destinatario si trova la lettera nella propria cassetta della posta. E anche qui, al massimo egli avr\u00e0 rapporti col postino (in motorino) incaricato di consegnargliela.</p> <p>Capito pi\u00f9 o meno cosa si intende per routing adesso vogliamo capire: chi se ne occupa? E come? Fisicamente il routing viene effettuato dai router, i dispositivi del livello di rete che organizzano la rete stessa. E come fanno? Ci riescono grazie a due concetti fondamentali, di cui parleremo a breve:</p> <ul> <li>il routing gerarchico</li> <li>le tabelle di routing</li> </ul>"},{"location":"routing/routing/#routing-gerarchico","title":"Routing gerarchico","text":"<p>Considerando il numero incredibile di reti diverse presenti su internet con IPv4 (oltre 2 milioni di reti), come \u00e8 possibile realizzare questa incredibile magia della tecnologia, del pensiero e dell'informatica che \u00e8 l'instradamento globale?</p> <p></p> <p>La risposta sta nell'organizzazione imposta alla rete da ICANN.  Questa organizzazione ha strutturato Internet in maniera gerarchica tramite l'assegnazione delle reti IP agli ISP (Internet Service Provider).</p> <p>Gli ISP organizzano il territorio ove si estende la propria rete e ove sono situati i loro clienti in maniera autonoma. ICANN definisce queste entit\u00e0 amministrative locali come Sistemi Autonomi (AS), ovvero gruppi di router e reti sotto il controllo di una singola e ben definita autorit\u00e0 amministrativa.</p> <p>Ogni Sistema Autonomo sulla rete Internet \u00e8 identificato da un numero a 16 bit (ASN, AS number).</p> <p>Il routing realizzabile grazie a questi AS si definisce routing gerarchico ed avviene su 2 diversi livelli:</p> <ol> <li>Routing Interno al Sistema Autonomo, in cui si utilizzano     protocolli di tipo IGP (Interior Gateway Protocol): ogni AS pu\u00f2     scegliere quello che preferisce.</li> <li>Di collegamento tra Sistemi Autonomi, in cui si utilizza un     unico protocollo di tipo EGP (Exterior Gateway Protocol): non     voglio togliervi la suspence e anticiparvi il nome...</li> </ol> <p>Ipotizziamo ad esempio di voler inviare un pacchetto dall'Italia agli Stati Uniti, che appartengono ovviamente a Sistemi Autonomi diversi; il pacchetto viene inviato procedendo secondo i seguenti livelli di routing:</p> <ol> <li>routing interno al sistema autonomo dove si trova il mittente (molto     pi\u00f9 ristretto di un routing globale)</li> <li>routing esterno ai sistemi autonomi (eseguito considerando gli AS     come punti della mappa), per portare il pacchetto dall'AS del     mittente a quello del destinatario.</li> <li>routing interno al sistema autonomo del destinatario</li> </ol> <p>Il pacchetto che \u00e8 partito dal nostro dispositivo in Italia e di cui attualmente sappiamo solo aver raggiunto il default Gateway verr\u00e0 analizzato dal primo router in cui capita che si domander\u00e0 semplicemente: l'IP del destinatario \u00e8 in una rete che conosco? (ovvero \u00e8 all'interno del mio AS?) No. Allora lo mando verso l'esterno del Sistema Autonomo.</p> <p>Arrivato all'esterno del sistema autonomo, i router analizzeranno il pacchetto guardando il suo indirizzo di destinazione e si chiederanno: In quale AS si trova questo indirizzo? Portiamolo l\u00ec.</p> <p>Arrivato nel Sistema Autonomo del destinatario, l\u00ec dovranno sapere precisamente come raggiungere la rete di appartenenza dell'IP del destinatario. Arrivati ad un dispositivo della stessa si potr\u00e0 procedere al mittente vero e proprio individuandolo ancora tramite ARP.</p> <p>Non \u00e8 facile, \u00e8 quasi magia. Ma \u00e8 la modalit\u00e0 pi\u00f9 semplice in cui sono riuscito a spiegarlo. La prossima lezione accanitevi nelle domande :)</p>"},{"location":"routing/routing/#tabelle-di-routing","title":"Tabelle di Routing","text":"<p>Quando un pacchetto arriva su un router, questo consulta una tabella per capire dove indirizzarlo per il prossimo \"salto\". E poi ce lo spedisce. Semplice e veloce. Il routing, ovvero la scelta del percorso da effettuare (o almeno del prossimo \"pezzo\" del percorso) si fa consultando le tabelle di routing. I protocolli di routing intervengono per la creazione delle tabelle di routing, non per il routing vero e proprio!</p> <p>Ogni spostamento da un router ad un altro viene definito salto, un hop. Ogni salto diminuisce (di uno) il TTL (Time To Live) di un pacchetto.</p> <p>Una tabella di routing \u00e8 costituita da almeno 3 campi:</p> <ul> <li>l'identificativo della rete di destinazione (tipicamente, un network address)</li> <li>la Subnet Mask utilizzata per definire la rete di destinazione</li> <li>il gateway per la destinazione finale (next hop)</li> </ul> <p>Vediamo un esempio:</p> Network Mask Gateway 100.0.0.0 255.0.0.0 100.100.1.75 170.50.0.0 255.255.0.0 200.200.2.150 200.150.100.0 255.255.255.0 150.150.150.150 <p>Ricapitolando: un pacchetto arriva su un router con la tabella di routing qui sopra.</p> <p>Si diminuisce di 1 il suo TTL e lo si controlla: se \u00e8 zero, il pacchetto viene eliminato.</p> <p>Si controlla il suo indirizzo IP di destinazione per cercare di capire verso quale destinazione inviarlo. La tabella si legge dalla prima all'ultima riga (l'ordine \u00e8 fondamentale). La prima riga che soddisfa il pacchetto viene utilizzata. Se nessuna riga coincide con la sua destinazione, il pacchetto viene eliminato.</p> <p>Per determinare la destinazione di un pacchetto si prende la prima riga e si applica la subnet mask all'indirizzo di destinazione del pacchetto. Si ottiene un indirizzo di rete. Se questo coincide con l'indirizzo di rete indicato nella prima riga si procede all'invio verso il gateway corrispondente. Altrimenti si procede alla riga successiva. Come dicevo prima, se finiscono le righe senza trovare una destinazione si elimina il pacchetto.</p> <p>Come si mettono d'accordo i due concetti principali che abbiamo appena illustrato, ovvero routing gerarchico e tabelle di routing?</p> <p>Prover\u00f2 ancora a spiegare la questione con un esempio. Immaginate che un AS gestisca al suo interno 5 reti come nella figura sotto. Tutto il resto \u00e8 considerato esterno al Sistema Autonomo. </p> <p></p> <p>Allora la tabella di routing del router indicato come R1 sar\u00e0 cos\u00ec:</p> Network Mask Gateway 11.0.0.0 255.0.0.0 11.10.9.8 12.0.0.0 255.0.0.0 12.3.4.5 13.0.0.0 255.0.0.0 13.4.5.6 14.0.0.0 255.0.0.0 11.10.9.8 15.0.0.0 255.0.0.0 12.3.4.5 0.0.0.0 0.0.0.0 7.4.7.4 <p>Se il pacchetto \u00e8 destinato ad una delle reti elencate nelle prime 5 righe utilizza il gateway indicato. Altrimenti viene indirizzato dall'ultima riga (qualunque indirizzo a cui viene applicata la maschera 0.0.0.0 diventa 0.0.0.0) verso il gateway 7.4.7.4 ovvero sparato in uscita dal Sistema Autonomo.</p>"},{"location":"routing/routing/#algoritmi-di-routing","title":"Algoritmi di routing","text":"<p>Gli algoritmi utilizzati per il routing dinamico si dividono in due categorie:</p> <p>Algoritmi DISTANCE-VECTOR Basati sul vettore delle distanze. Utilizzano l'algoritmo Bellman-Ford. Calcolano la distanza dai router vicini secondo una metrica e la comunicano a ognuno di essi; man mano che le informazioni si divulgano, i router calcolano la distanza con i nuovi router che prima non conoscevano e si crea tutta la tabella di routing.</p> <p>Algoritmi LINK-STATE Basati sullo stato del collegamento. Utilizzano l'algoritmo di Dijkstra. Tutti i nodi si scambiano informazioni sul costo dei collegamenti coi vicini tramite multicast. Quando ogni nodo ha ricevuto tutte le informazioni, usa l'algoritmo per determinare il  cammino minimo per raggiungere ogni nodo, ponendo se stesso come radice dell'albero dei cammini minimi.</p> <p></p> <p>Il protocollo RIP</p> <p>RIP (Routing Information Protocol) \u00e8 un protocollo IGP di tipo distance-vector pubblicato nel 1988 con l'RFC 1058 e revisionato con terrificante regolarit\u00e0 negli anni successivi; ha avuto una grandissima diffusione fino a quando non e stato messo a punto OSPF, protocollo di tipo link-state, standard attuale per il routing fra gateway interni.</p> <p>RIP impiega il conteggio dei numeri di salti (hop count) come metrica di routing. Il massimo numero di hop permessi \u00e8 15. Ogni router RIP trasmette di default, ogni 30 secondi, la propria tabella completa di routing a tutti i vicini direttamente collegati, generando grande traffico dati, spesso inutile per la staticit\u00e0 di molte reti</p> <p></p> <p>Il protocollo OSPF</p> <p>OSPF (Open Shortest Path First) \u00e8 un protocollo IGP di tipo link-state basato su uno standard aperto (OSPF 2.0, RFC 2178, anno 1997) che \u00e8 in grado di adattarsi velocemente ai cambiamenti di topologia e supportare vari tipi di metriche, ad un costo per\u00f2 non nullo per la rete.</p> <p>Le informazioni di modifica dello \"stato del collegamento\" vengono inviate in multicast a tutti i router della rete gestita tramite esso, aggiornando (continuamente) lo stato complessivo della rete.</p> <p></p> <p>Il protocollo BGP</p> <p>BGP (Border Gateway Protocol) \u00e8 il protocollo EGP di tipo distance-vector che agisce nel \"cuore\" di Internet, la cui prima versione ufficiale \u00e8 datata 1990, con l'RFC 1267.</p> <p>Viene utilizzato per scambiare informazioni fra i router che appartengono a sistemi autonomi distinti (i cosiddetti gateway routers) da cui il nome del protocollo.</p> <p>Si tratta di un protocollo di routing ad indicazione di percorso che non si basa su metriche o algoritmi tecnici per l'indicazione del percorso, ma agisce basandosi su regole specifiche definite su ciascun sistema autonomo da accordi politici fra i vari \"proprietari\" (o forse dovevo scrivere \"gestori\"?) dei sistemi autonomi.</p> <p> </p>"},{"location":"teoria/01_suite_internet/","title":"La Suite Internet","text":"<p>La <code>Internet Protocol Suite</code> \u00e8 un insieme di protocolli di rete che implementa la pila di protocolli su cui funziona Internet. </p> <p>Se la cercate in rete o nella letteratura attuale, la troverete nominata in vari modi: Internet Protocol Suite, o pi\u00f9 semplicemente Suite Internet,  o addirittura con il nomignolo TCP/IP, che deriva dalla grande importanza storica  dei suoi due protocolli pi\u00f9 rappresentativi: TCP e IP.</p> <p>Protocolli (di rete) e suite(s)</p> <p>Un protocollo \u00e8 un insieme di regole utilizzate per favorire la comunicazione tra due o pi\u00f9 entit\u00e0.  Ovviamente nel caso specifico di un protocollo di rete, queste regole andranno a definire le modalit\u00e0 di interazioni fra due o pi\u00f9 dispositivi.  Uno stack (o una suite) di protocolli \u00e8 un insieme di protocolli che collaborano fra loro per ottenere uno scopo comune.</p> <p>La necessit\u00e0 di implementare realmente i livelli descritti ha portato ad una semplificazione di alcune parti del modello OSI, come si desume dalla figura seguente:</p> <p></p> <p>Il livello superiore, la cui implementazione \u00e8 affidata al software, si occupa di stabilire le regole che permettono ai dati utente di essere trasportati in maniera organizzata: si passa quindi dai dati (chat, siti web, files, etc...) ai blocchi, insiemi organizzati di dati.</p> <p>Il livello di trasporto, implementato a livello di Sistema Operativo, si occupa prevalentemente di individuare il mittente e il destinatario della comunicazione, ovvero il punto di partenza dei blocchi che arrivano dal livello superiore e il punto ove questi devono arrivare.</p> <p>Il livello di rete, implementato nel firmware (driver, router, etc), si occupa di due compiti fondamentali: preparare i pacchetti dati che saranno inviati, completi delle informazioni arrivate dai livelli precedenti, e stabilire il percorso che i pacchetti devono compiere per arrivare dal mittente al destinatario.</p> <p>Infine il livello inferiore, implementato a livello hardware, si occupa di trasformare i pacchetti logici in segnali fisici.</p> <p>NOTA: qui ci va un disegnino sul funzionamento della suite: la storia di un pacchetto!!!</p> <p>Semplice e schematico </p>"},{"location":"teoria/02_assoc/","title":"Gestione e Sviluppo di Internet","text":"<p>Due parole sulle associazioni che gestiscono la rete Internet cos\u00ec come la conosciamo.</p>"},{"location":"teoria/02_assoc/#lo-sviluppo-dei-protocolli-dello-stack-tcpip","title":"Lo sviluppo dei protocolli dello Stack TCP/IP","text":"<p>Se avete seguito bene la discussione sull\u2019affermazione della Suite Internet sulle suite supportate nientemeno che da tre delle aziende pi\u00f9 importanti della storia dell\u2019informatica (Microsoft, Apple, Novell), ci sar\u00e0 una questione che probabilmente non vi ha convinto del tutto: chi \u00e8 che ha \u201cpensato\u201d i protocolli della Suite Internet??? Ok... all\u2019inizio abbiamo detto che \u00e8 stato un lavoro a pi\u00f9 mani iniziato all\u2019universit\u00e0 di Berkeley, nel Sud della California... molti avranno sentito anche la storia della rete ARPAnet, storicamente considerata l\u2019antenata della rete Internet e sovvenzionata dall\u2019esercito degli Stati Uniti...</p> <p>Ma adesso chi porta avanti lo sviluppo delle idee e dei protocolli? E chi gestisce tutto questo ambaradan? Andiamo avanti ancora con le idee degli anni 70-80?? No...</p> <p>La risposta a questa domanda sta in 3 associazioni diverse, con composizione e scopi diversi, ma con acronimi simili, che quasi te le fa confondere: IETF, IEEE, ICANN.</p> <p>IETF (Internet Engineering Task Force, https://www.ietf.org/ \u00e8 un  organismo internazionale libero, composto da tecnici, specialisti e ricercatori appassionati allo sviluppo dei protocolli e delle tecnologie della rete Internet.</p> <p>E\u2019 un organismo senza una sede fisica, se non il web (The Internet).</p> <p>La missione di IETF \u00e8 quella di promuovere lo sviluppo aperto dei nuovi protocolli della Suite Internet, tramite la stesura di documenti aperti alla discussione da parte di chiunque, denominati RFC (Request For Comments).</p> <p>Finita la discussione e approvato il documento da tutta l\u2019associazione, l\u2019RFC diventa immutabile e diviene come se fosse una legge di Internet. Non \u00e8 possibile eliminare un RFC approvato, ma \u00e8 possibile superarlo con un RFC successivo.</p> <p>Ad esempio la prima versione del protocollo IP risale all\u2019RFC numero 760, che poi \u00e8 stato reso obsoleto dai successivi 777, 791 ( IPv4 ), aggiornato da 792, 1349, 2474 e nuovamente reso obsoleto da 2460 ( IPv6 ) e cos\u00ec via... Non pensavate a tanto fermento dietro ad un solo protocollo eh?</p> <p>Tutti gli RFC sono pubblicati in ASCII (No Word, No Pdf, No immagini, solo testo semplice!!!) sul sito IETF. Diamo un occhio al famoso RFC 791.</p> <p> </p> <p>La seconda associazione che entra in gioco si chiama IEEE , una associazione americana senza scopo di lucro che raduna scienziati professionisti riconosciuti a livello internazionale e che si prefigge l\u2019obiettivo di promuovere le nuove tecnologie.</p> <p>IEEE (Institute of Electrical and Electronics Engineers, https://www.ieee.org/)  \u00e8 una associazione che raggruppa ingegneri e scienziati di tutte le pi\u00f9 grandi aziende del mondo, che collaborano alla creazione di nuovi standard per l\u2019elettronica, l\u2019informatica, l\u2019elettrotecnica e le telecomunicazioni.</p> <p>Anche qui ci troviamo di fronte ad una associazione che promuove la creazione di \u201cstandard\u201d per il settore.</p> <p>Cerchiamo di farla semplice. IETF si occupa di formalizzare tutti i protocolli del livello superiore, di trasporto e di rete. IEEE si occupa di tutte le specifiche (anche hardware) che afferiscono al livello inferiore.</p> <p>Storicamente questo finto dualismo si spiega col fatto che le implementazioni dei livelli \u201calti\u201d hanno sempre avuto bisogno delle migliori idee per svilupparsi al meglio e la struttura di IETF permette a chiunque di contribuire ad una idea o di portare la propria; quando si parla del livello inferiore andiamo a toccare la sfera di appartenenza dei produttori di hardware, che in IEEE spesso trovano il giusto compromesso fra innovazione e collaborazione.</p> <p>E la terza societ\u00e0? \u00c8 quella che si occupa di gestire il tutto!</p> <p> </p> <p>ICANN (Internet Corporation for Assigned Names and Numbers, https://www.icann.org/)  \u00e8 un ente di gestione internazionale registrato presso il Dipartimento del commercio degli Stati Uniti. </p> <p>Fondata nel 1998, dal 2016 ha pieno controllo sui 3 compiti fondamentali di gestione della rete Internet:</p> <ol> <li> <p>la gestione e lo smistamento degli indirizzi IP</p> </li> <li> <p>la gestione e l\u2019organizzazione dei nomi di dominio</p> </li> <li> <p>la gestione e il supporto dei protocolli della rete Internet</p> </li> </ol> <p>Qui potremo discutere giorni sulla frasetta \u201c...presso il Dipartimento del commercio...\u201d. Non preoccupatevi. Sono anni che il mondo discute su questa cosa. E ancora non si \u00e8 arrivati ad una conclusione degna di questo nome. ICANN verr\u00e0 fuori nei nostri discorsi quando parleremo dei protocolli da lei direttamente gestiti.</p> <p> </p>"},{"location":"trasporto/lab_netstat/","title":"netstat","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: Windows: command prompt. Linux, Mac: terminale</p> <p>Argomenti trattati: Protocolli di trasporto</p> <p>L'utility di rete netstat permette di esaminare le connessioni attive, individuando le porte attive nel proprio dispositivo e quelle disponibili a ricevere dati in ingresso.</p> <p>Permette inoltre (cose che a noi interessano meno) di visualizzare statistiche relative a connessioni di rete, tabelle di routing, interfacce di rete, masquerading e multicasting.</p> <p>Vediamo le principali opzioni:</p> Opzione per Windows Opzione per Linux e Mac Significato -a -a Visualizza tutte le connessioni, attive e non -n -n Visualizza i dati (IP e porta) in forma numerica, senza risoluzione -o -p Visualizza il PID (identificatore) del processo che occupa quella porta -p TCP -t Visualizza tutte (e solo) le connessioni TCP -p UDP -u Visualizza tutte (e solo) le connessioni UDP <p>Provate a combinare le varie opzioni, seguendo la sintassi del sistema operativo che state utilizzando, osservando i risultati.</p> <p> </p>"},{"location":"trasporto/lab_nmap/","title":"nmap","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: Windows, Linux, Mac</p> <p>Argomenti trattati: Protocolli di trasporto</p> <p>Nmap \u00e8 un software libero distribuito con licenza GNU GPL da Insecure.org (https://insecure.org) e disponibile per il download sul sito https://nmap.org/ creato per effettuare port scanning, cio\u00e8 mirato all'individuazione di porte aperte su un computer bersaglio o anche su range di indirizzi IP, in modo da determinare quali servizi di rete siano disponibili.</p> <p>Vediamo la sintassi di base:</p> <pre><code>$ nmap OPTIONS TARGET\n</code></pre> <p>Il TARGET \u00e8 il dispositivo o l'elenco di dispositivi che nmap deve scannerizzare per capire il tipo di dispositivo che ci troviamo davanti (produttore, sistema operativo, servizi attivi) e pu\u00f2 essere uno tra questi:</p> <ul> <li><code>HOST</code>: ad esempio ciccio, oppure 192.168.1.1</li> <li><code>RANGE</code>: ad esempio 192.168.1.1-20</li> <li><code>SUBNET</code>: ad esempio 192.168.1.0/24</li> </ul> <p>Ricorda comunque che la scansione che nmap esegue richiede del tempo quindi occhio ad impostare RANGE o SUBNET troppo ampi...</p> <p>Le OPTIONS disponibili sono tranquillamente un migliaio... noi qui ovviamente noi vediamo le pi\u00f9 semplici e interessanti:</p> <p>Relativit\u00e0</p> <p>nmap \u00e8 un software molto veloce considerato quello che fa e come lo fa.</p> <p>Il problema \u00e8 che impiega comunque un buon minuto per una scansione, quindi agli occhi delle persone normali risulta lentissimo.</p> <p>Fra le opzioni ne abbiamo anche una per la velocit\u00e0, con 5 possibilit\u00e0: -T0 (pi\u00f9 lento ed accurato), -T1, -T2, -T3, -T4, -T5 (pi\u00f9 veloce e potenzialmente impreciso).</p> <p>Sta a voi decidere se e quale usare se l'attesa diventa insopportabile</p> <p>L'opzione pi\u00f9 veloce di scansione controlla solo le 100 porte pi\u00f9 comuni:</p> <pre><code>$ nmap -F TARGET\n</code></pre> <p>La scansione di default senza privilegi amministrativi viene fatta con il 3-way handshake (TCP scan):</p> <pre><code>$ nmap -sT HOST\n</code></pre> <p>Se si hanno privilegi amministrativi \u00e8 meglio procedere ad un SYN scan (pi\u00f9 discreto e pi\u00f9 veloce)</p> <pre><code>$ sudo nmap -sS HOST\n</code></pre> <p>TCP scan vs SYN scan</p> <p>Mentre un 3-way handshake prevede l'invio e la ricezione di 3 pacchetti con l'attivazione di una connessione fra i 2 host e permette dunque al sistema target di accorgersi del dispositivo che lo scansiona, un SYN scan invia al TARGET solo il primo pacchetto dell'handshake e determina l'apertura di un servizio con la ricezione del pacchetto SYN+ACK, ma non risponde con un ACK ad esso, non aprendo la connessione sul target!</p> <p>Le due precedenti scansioni ci elencano semplicemente le porte che rispondono o no al 3-way handshake. Per determinare i servizi realmente attivi dietro alle porte attive:</p> <pre><code>$ nmap -sV TARGET\n</code></pre> <p>Per cercare di capire il sistema operativo del dispositivo target (richiede privilegi amministrativi):</p> <pre><code>$ sudo nmap -O TARGET\n</code></pre> <p>Per una scansione generica di quale potrebbe essere il sistema operativo e i servizi attivi:</p> <pre><code>$ nmap -A HOST\n</code></pre> <p>Se si vuole capire quali sono gli host online in una rete:</p> <pre><code>$ nmap -sn SUBNET\n</code></pre>"},{"location":"trasporto/lab_nmap/#porte-scansionate","title":"Porte scansionate","text":"<p>Quando nmap scansiona le porte logiche di un dispositivo TARGET pu\u00f2 ritornare risultati di 6 tipi:</p> Classificazione Porta Descrizione open Una porta che accetta connessioni closed Accessibile ma senza una applicazione in ascolto su di essa. Permette di capire che un sistema \u00e8 attivo e senza firewall. filtered Non si pu\u00f2 determinare con esattezza se la porta sia aperta o no. Le porte protette dai firewall sono cos\u00ec. unfiltered Una porta non protetta da firewall, ma che non si capisce se sia aperta o meno. Un amministratore acuto si nasconde di solito dietro ad essa... open filtered closed filtered"},{"location":"trasporto/lab_nmap/#nmap-scripting-engine-nse","title":"Nmap Scripting Engine (NSE)","text":"<p>Attenzione!</p> <p>Da un grande potere deriva una grande responsabilit\u00e0</p> <p>(zio Ben)</p> <p>La caratteristica migliore di nmap \u00e8 la possibilit\u00e0 di aumentare a dismisura le sue capacit\u00e0 di scanning grazie al meccanismo degli script e al suo NSE ovvero il software in grado di eseguirli.</p> <p>Sono presenti centinaia di script per le scansioni pi\u00f9 disparate, organizzati nelle seguenti categorie:</p> Categoria Descrizione auth Script per l'autenticazione e i privilegi utente. broadcast Network discovery basato su broadcast. brute Attacchi di tipo brute-force per indovinare le credenziali di accesso. default Gli script pi\u00f9 popolari e considerati pi\u00f9 utili. discovery Network, Service and Host discovery dos Attacchi di tipo \"Denial of service\" exploit Service exploitation on different CVEs external Scripts che si appoggiano a servizi o dati esterni per funzionare fuzzer Attacchi di tipo fuzzing ad app, servizi, reti. intrusive Attacchi aggressivi che potrebbero danneggiare il funzionamento della rete. malware Malware detections and exploration scripts safe Safe and non-intrusive/noisy scripts version OS, service and software detection scripts vuln Vulnerability detection and exploitation scripts <p>Viste le categorie complete, sappiate che un elenco completo degli script disponibili con una descrizione esplicativa  accanto si trova sul sito https://nmap.org/nsedoc/.</p> <p>Per quanto riguarda il nostro corso, diciamo che prima di poter utilizzare gli script \u00e8 bene assicurarsi che essi siano presenti, aggiornati all'ultima versione disponibile e catalogati nel database del sistema. Si ottiene questo risultato eseguendo il comando:</p> <pre><code>$ sudo nmap --script-updatedb\n</code></pre> <p>Fatto questo, la sintassi per eseguire gli script \u00e8 molto semplice e si basa sull'opzione <code>--script</code>: ho fatto alcuni esempi per capire il funzionamento.</p> <pre><code>// SINTASSI GENERALE\n$ sudo nmap --script QUALCOSINA TARGET\n\n// Per eseguire tutti gli script di default verso un TARGET \nsudo nmap --script default TARGET\n\n// Per eseguire gli script dei gruppi broadcast e discovery verso un TARGET\nsudo nmap --script broadcast,discovery TARGET\n\n// come sopra, esattamente equivalente\nsudo nmap --script \"broadcast or discovery\" TARGET\n\n// Per eseguire tutti gli script relativi ad HTTP verso un target\nsudo nmap --script http* TARGET\n\n// Per eseguire lo script chiamato dhcp-discover verso un target\nsudo nmap --script dhcp-discover TARGET\n\n// Per eseguire solo gli script relativi ad HTTP del gruppo discovery verso un target\nsudo nmap --script \"http* and discovery\" TARGET\n</code></pre>"},{"location":"trasporto/lab_nmap/#esempi-ed-esercizi","title":"Esempi ed Esercizi","text":"<p>Nel primo esempio proveremo ad interrogare il server DHCP per ottenere le informazioni di rete, fingendo di essere un client DHCP (con un MAC inventato) e visualizzando le informazioni ottenute senza realmente applicarle.</p> <pre><code>// l'opzione -sU indirizza la scansione sul protocollo UDP\n// l'opzione -p 67 individua la porta del server DHCP: velocizza la scansione\n// lo script si chiama dhcp-discover\n$ sudo nmap -sU -p 67 --script dhcp-discover IP_SERVER_DHCP\n</code></pre> <p>Nel secondo esempio proviamo ad elencare le cartelle condivise da un generico PC con Windows, per ottenere informazioni su cartelle condivise eventualmente accessibili.</p> <pre><code>// opzione (-sU) per scansione UDP, opzione (-sS) per scansione TCP SYN\n// Le porte elencate (137/udp e 139/tcp) servono per velocizzare le operazioni\n// lo script si chiama smb-enum-shares\n$ sudo nmap -sU -sS -p U:137,T:139 --script smb-enum-shares IP_SERVER_SMB\n</code></pre> <p>Nel terzo esempio proviamo ad ottenere informazioni dettagliate sul PC Windows che ci interessa studiare.</p> <pre><code>// opzione (-sU) per scansione UDP, opzione (-sS) per scansione TCP SYN\n// Le porte elencate (137/udp e 139/tcp) servono per velocizzare le operazioni\n// lo script si chiama smb-system-info\n$ sudo nmap -sU -sS -p U:137,T:139 --script smb-system-info IP_SERVER_SMB\n</code></pre> <p>Nel quarto esempio faremo fare a nmap una scansione tipo traceroute di tutti gli hop attraversati con la localizzazione geografica delle posizioni di ognuna.</p> <pre><code>$ sudo nmap --traceroute --script traceroute-geolocation TARGET\n</code></pre> <p>Nel quinto esempio simuleremo un attacco (di 10 minuti) ad un server DNS allo scopo di testare la qualit\u00e0 della rete e del servizio DNS di quest'ultima. Attenzione...</p> <pre><code>$ sudo nmap -sU --script dns-fuzz TARGET\n</code></pre> <p>Nel sesto e ultimo esempio utilizzeremo uno script di tipo brute per tentare di indovinare nome utente e password di un utente collegato ad un Mac. Anche questo script ha ovviamente l'unico scopo di scoraggiare l'utilizzo di nomi utente e password semplici da indovinare.</p> <pre><code>$ sudo nmap -p 548 --script afp-brute IP_COMPUTER_MAC\n</code></pre> <p> </p>"},{"location":"trasporto/lab_port_forwarding/","title":"Port Forwarding","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: Browsing</p> <p>Argomenti trattati: Protocolli di trasporto</p> <p>Il Port Forwarding \u00e8 una abilit\u00e0 del livello di trasporto che permette di reindirizzare una connessione destinata ad un certo socket verso un altro socket, quando questa attraversa un dispositivo di rete (un router o un firewall). Esso \u00e8 dunque una applicazione di NAT (Network Address Translation) poich\u00e9, spostando uno dei socket target della connessione rende possibile modificare l'IP (ovvero il mittente, oppure il destinatario) della stessa.</p> <p>L'idea di questa esercitazione, da fare a casa, \u00e8 quella di rendere disponibile un servizio installato su un computer locale sulla rete internet, ridirigendo le richieste che arrivano al modem router di casa dalla linea esterna verso il dispositivo interno che esegue un servizio.</p> <p>Nella seguente immagine ho cercato di descrivere il problema immaginando un generico server WEB disponibile sul LAPTOP sulla porta 80 e raggiungibile dall'esterno tramite l'indirizzo IP (pubblico) del router.</p> <p></p> <p>Qualche minuto di tempo per analizzare (e godere) del disegno...</p> <p>Bene!</p> <p>Per questa esperienza vi servono alcune informazioni relative alla rete di casa vostra. Un buon inizio sarebbe individuare:</p> <ul> <li>l'IP del vostro dispositivo (possibilmente un PC, oppure un Raspberry)</li> <li>l'IP del modem/router/access point di casa vostra</li> </ul> <p>Non dovrebbe essere difficile desumerli osservando l'output del comando ipconfig (Windows) oppure ifconfig (Linux, Mac). L'IP del proprio dispositivo \u00e8 quello indicato accanto alla scheda di rete; l'IP del proprio dispositivo di rete \u00e8 solitamente il gatewar/server DHCP che desumete dalle informazioni di rete.</p> <p>Adesso dovete collegarvi al router di casa vostra. Di solito le informazioni di accesso (IP, user, pass) sono proprio sul router, su una etichetta o su una placchetta sul retro/fondo del dispositivo.</p> <p>Collegatevi utilizzando il browser e digitando l'URL: http://IP_del_router. Ad esempio potrebbe essere qualcosa tipo http://192.168.1.1. A casa mia la rete \u00e8 un p\u00f2 particolare :)</p> <p></p> <p>Adesso all'interno dell'interfaccia di configurazione del router dovete trovare qualcosa tipo configurazione porte, port Forwarding, virtual server, etc...</p> <p></p> <p>Da l\u00ec la configurazione \u00e8 diversa per ogni router... posso aiutarvi poco :(</p> <p>Quello che dovete fare \u00e8 abbinare i due socket che devono comunicare (quello sul dispositivo e quello sul router).</p> <p>IP del router : 80 -----&gt; IP del PC/Raspberry : 80</p> <p>Ricordate che siete sull'interfaccia del router, quindi il suo IP \u00e8 solitamente implicito. Resta da indicare la porta da ascoltare (nel nostro esempio la porta 80, HTTP) e il socket che la deve ricevere (IP del dispositivo, il PC o il Raspberry, e ancora porta 80 oppure porta HTTP).</p> <p>Buona Fortuna!</p> <p>PS: fortuna, un corno! Dovete riuscirci...</p> <p>PPS: quello che poi potete farci con il port Forwarding dipende dalle vostre conoscenze sul livello superiore!</p> <p> </p>"},{"location":"trasporto/lab_wireshark/","title":"Wireshark","text":"<p>Argomenti teorici e requisiti tecnici</p> <p>Prerequisti: Windows, Mac, Linux</p> <p>Argomenti trattati: Protocolli di rete e di trasporto. Pi\u00f9 tutto il resto</p> <p>WireShark \u00e8 un analizzatore di rete molto diffuso e molto potente, appartenente alla classe degli sniffer di rete.  Usarlo tuttavia, almeno per operazioni di base o di studio del funzionamento della rete, \u00e8 relativamente semplice.</p> <p>Vedremo qui semplicemente una minima parte delle funzioni pi\u00f9 importanti, come la cattura dei pacchetti, la selezione di questi ultimi per mezzo dei filtri e alcune funzioni che tornano comode soprattutto quando c'\u00e8 una grossa mole di dati.</p> <p>Per prima cosa occorre selezionare l'interfaccia di rete dalla quale si vogliono catturare i pacchetti in transito. Questa operazione attiver\u00e0 la scheda in modalit\u00e0 <code>promiscua</code>, cio\u00e8 la render\u00e0 capace di intercettare tutti i pacchetti in transito sulla rete e non solo quelli destinati all'host.</p> <p></p> <p>Vediamo l'interfaccia principale di WireShark, cercando di capirne l'organizzazione:</p> <p></p> <p>Come si deve, il colpo d'occhio \u00e8 chiaro e semplice: i pacchetti sniffati sono studiati ed elencati in ordine di cattura. Selezionandone uno si hanno tutte le informazioni relative.</p> <p>Tra le funzioni utili di WireShark, elenchiamo le due pi\u00f9 usate:</p> <ol> <li>L'opzione follow X Stream dove X \u00e8 uno tra TCP e UDP, permette     di evidenziare il flusso di una comunicazione a cui il pacchetto     selezionato appartiene. In questo modo si esce dall'ordinamento     classico \"per cattura\" e si ottiene una lista di tutti i pacchetti     relativi ad una connessione.</li> <li>L'opzione filtra pacchetti permette una selezione dei pacchetti     interessanti secondo un modello prestabilito.</li> </ol> <p></p> <p>La sintassi dei filtri \u00e8 analoga alle condizioni dei linguaggi di programmazione. Immaginiamo di voler vedere tutti i pacchetti diretti al dispositivo con IP 1.2.3.4. Allora il filtro diventa:</p> <pre><code>ip.addr == 10.2.4.200\n</code></pre> <p>Oppure, vogliamo visualizzare tutti i pacchetti del protocollo HTTP e DNS. I nomi dei protocolli funzionano come variabili booleane, le operazioni logiche utilizzano la sintassi del linguaggio C ( &amp;&amp; sta per AND, || sta per OR, ! sta per NOT), allora:</p> <pre><code>http &amp;&amp; dns\n</code></pre> <p>In ogni caso, ci sono 2 auti fondamentali che vengono da Wireshark per la compilazione dei filtri:</p> <ol> <li>l'autocompletamento: il software suggerisce come completare il     filtro che si inizia a scrivere</li> <li>il colore di sfondo: la barra dei filtri diventa rossa mentre si     scrive un filtro e passa al verde appena il filtro \u00e8 sintatticamente     corretto.</li> </ol>"},{"location":"trasporto/lab_wireshark/#usare-wireshark","title":"Usare WireShark","text":"<p>Capisco che introdurre un software come WireShark ci dica tutto e niente delle sue potenzialit\u00e0. Per capire davvero occorre provare!</p> <p>Proviamo a fare allora dei semplici esercizi per capire il funzionamento del software.</p> <ol> <li>Ricostruire una connessione HTTP (richiesta/risposta) elencando     TUTTI i pacchetti inviati.</li> <li>Filtrare tutti i pacchetti delle connessioni DNS, evidenziando i     record presenti nei pacchetti.</li> <li>Filtrare il traffico ARP, cercando di dedurre la struttura del     protocollo stesso dall'osservazione dei suoi pacchetti.</li> <li>Individuare un 3-way handshake TCP, valutando tempistiche e     funzionamento tramite osservazione dei pacchetti.</li> </ol> <p> </p>"},{"location":"trasporto/py_socket/","title":"Socket Programming","text":"<p>I socket sono oggetti software gestiti dal Sistema Operativo. Sono gli unici responsabili per qualunque connessione di rete. Anzi... pi\u00f9 precisamente una connessione di rete non \u00e8 altro che uno scambio di dati fra due socket! E chi chiede al sistema operativo di creare i socket? Le applicazioni!!!</p> <p>I socket permettono anche ai dispositivi di veicolare contemporaneamente pi\u00f9 connessioni logiche (ad esempio, due schede di un browser aperte) attraverso un'unica connessione fisica! Pi\u00f9 precisamente, per ogni dispositivo fisico di connessione alla rete sono disponibili 65.536 porte logiche  per la possibile creazione di altrettanti socket!</p> <p></p> <p></p> <p></p> <p>Come si evince chiaramente dalla figura, Ogni socket si individua grazie alla coppia di informazioni: <code>IP</code>, <code>PORTA LOGICA</code>.</p> <p>Ogni connessione alla rete viene individuata univocamente (nell'unit\u00e0 di tempo) dalla coppia di socket  che fanno da mittente e destinatario della stessa. </p> <p>Il livello di trasporto pu\u00f2 fornire due tipi di servizi, definiti in due protocolli diversi:</p> <ul> <li>Il protocollo TCP, per le connessioni punto a punto (1 a 1); connesso e affidabile</li> <li>Il protocollo UDP per le connessioni semplici (anche broadcast e multicast) senza alcuna sovrastruttura: non connesso e non affidabile.</li> </ul> <p>Ok... la teoria la sappiamo! Vediamo il codice adesso.</p>"},{"location":"trasporto/py_socket/#socket-in-python","title":"Socket in Python","text":"<p>Come dicevamo, i socket sono oggetti software gestiti dal Sistema Operativo e invocati dalle applicazoini. Come si crea un socket in Python??</p> <pre><code>import socket\n\n# Oggetto Socket TCP\ntcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Oggetto Socket UDP\nudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n</code></pre> <p>Anche qui... non mi sembra complicato :)</p> <p>Faremo adesso una prova di comunicazione client-server tramite il protocollo UDP.</p>"},{"location":"trasporto/py_socket/#comunicazione-clientserver-udp-in-python","title":"Comunicazione client/server UDP in Python","text":"<p>Vediamo il codice che crea un server con il protocollo UDP. Questo semplice programma si mette in attesa di comunicazioni. Poi a seconda del messaggio arrivato risponde OK se il numero di lettere arrivate \u00e8 pari, ERR se sono dispari.</p> UDP Server in Python<pre><code>import socket\n\nlocalIP = \"192.168.110.200\"  # Qui ci va il tuo IP, come stringa\nlocalPort = 20000            # Qui ci va una porta (&gt; 1024), come intero\n\n# UDP Socket Object\nudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Bind to address and ip\nudp_socket.bind( (localIP, localPort) )\n\nprint(\"UDP server up and listening\")\n\n# Listen for incoming datagrams\nwhile True:\n    message,address = udp_socket.recvfrom(1024)\n\n    print(\"Message from Client:\", message.decode() )\n    print(\"Client IP Address:\", address)\n\n    msgFromServer = \"OK\"\n    if len(message) % 2 == 1:\n        msgFromServer = \"Err\"\n    bytesToSend = str.encode(msgFromServer)\n\n    # Sending a reply to client\n    udp_socket.sendto(bytesToSend, address)\n</code></pre> <p></p> <p>Ovviamente abbinato al server, che deve essere in esecuzione, ci va un client che deve tentare la connessione e l'invio allo stesso. Ecco il codice che permette di inviare al server un messaggio qualunque.</p> <p></p> UDP Client in Python<pre><code>import socket\n\nServer_IP   = \"192.168.110.200\"  # Qui ci va l'IP del dispositivo che esegue il tuo server, come stringa\nServer_PORT = 20000              # Qui ci va la porta del tuo server (la devi sapere), come intero\n\nMESSAGE = input(\"text to send: \")\n\nprint(\"UDP target IP: \", Server_IP)\nprint(\"UDP target port: \", Server_PORT)\nprint(\"message: \", MESSAGE)\n\n# UDP Socket Object\nudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nudp_socket.sendto(MESSAGE.encode(), (Server_IP, Server_PORT))\n\nmessage,address = udp_socket.recvfrom(1024)\n\nprint(\"Reply from Server:\", message.decode() )\nprint(\"Server IP Address:\", address)\n</code></pre> <p>Adesso basta solo provare :)</p>"},{"location":"trasporto/py_socket/#esercizi-su-socket-udp","title":"Esercizi su socket UDP","text":"<p>Alcuni esercizi per prendere confidenza con i socket UDP</p> <p>Esercizio 3301</p> <p>Implementare un peer ovvero un programma che contiene contemporaneamente client e server UDP. Eseguirne due copie in grado di  colloquiare alternativamente fra loro: il primo manda un msg di testo al secondo, il secondo lo vede e manda una risposta (digitata dall'utente) al primo, il primo legge la risposta e pu\u00f2 rispondere... e cos\u00ec all'infinito (finch\u00e9 non si interrompe il programma).</p> <p>Esercizio 3301 bis</p> <p>Implementare un peer ovvero un programma che contiene contemporaneamente client e server UDP. Eseguirne tre o quattro copie (opportunamente configurate)  in grado di colloquiare fra loro secondo un ordine prestabilito: il primo manda un msg di testo agli altri tre, poi il secondo, poi il terzo, poi il quarto e si ricomincia. Tutti ricevono i messaggi di tutti</p> <p>Esercizio 3301 ter</p> <p>Implementare un server in grado di servire quattro persone che parlano fra di loro. Questo riceve un msg da uno qualsiasi dei client e lo invia agli altri tre. Implementare un client in grado di inviare messaggi al server e di riceverli. Modificare il client in modo da stabilire l'ordine con cui le persone parlano (vedi 3301 bis).</p> <p>Esercizio 3301 quater</p> <p>Implementare un server in grado di servire un numero imprecisato di client. Ogni volta che un client invia un messaggio questi viene aggiunto alla lista dei client a cui inviare i messaggi degli altri. Il client dell'esercizio precedente dovrebbe funzionare bene anche con questo server.</p> <p>Esercizio 3301 quinquies GUI</p> <p>Il server \u00e8 quello dell'esercizio precedente. Il client ha le stesse funzionalit\u00e0 di prima, ma implementa una interfaccia grafica in wxPython.</p> <p>Esercizio 3302</p> <p>Implementare un peer ovvero un programma che contiene contemporaneamente client e server UDP. Entrambi possono scrivere quando vogliono e visualizzano i messaggi che arrivano nell'istante in cui lo fanno.</p> <p>Esercizio 3302 GUI</p> <p>Come l'esercizio precedente, ma fornendo una GUI scritta in wxPython</p> <p>Esercizio 3303</p> <p>Coppia di programmi che permettono di inviare file di testo semplice fra programma e programma. Individuare il file (ad esempio con l'ausilio della libreria pathlib) e inviate la stringa [NOME_FILE + \"\\n\\n\" + CONTENUTO_FILE ]. Il client \u00e8 in grado di salvare nella stessa cartella dello script il file con il nome inviato.</p> <p>Esercizio 3303 GUI</p> <p>Come l'esercizio precedente, ma fornendo una GUI scritta in wxPython.  Eventualmente nel programma di ricezione si pu\u00f2 permettere all'utente di selezionare DOVE salvare il file</p>"},{"location":"trasporto/py_socket/#comunicazione-clientserver-tcp-in-python","title":"Comunicazione client/server TCP in Python","text":"<p>TCP \u00e8 un protocollo ben pi\u00f9 complicato di UDP! Vi espongo le differenze fondamentali:</p> <ul> <li>il socket del server, prima di poter ricevere connessioni, dovr\u00e0 porsi in modalit\u00e0 <code>listen</code></li> <li>il client, prima di poter inviare dati al server, dovr\u00e0 stabilire una <code>connessione</code> con il socket del server</li> <li>Una volta stabilita la connessione, i dati tra i due socket saranno veicolati tramite essa, con i metodi <code>sendall</code> e <code>recv</code></li> <li>I dati di passaggio nella connessione sono per forza di cose ordinati! (A questo ci pensa TCP... noi non dobbiamo fare nulla. Solo sapere...)</li> <li>Alla fine dello scambio di dati la connessione va chiusa con il metodo <code>close</code> da parte di entrambi i socket!!!</li> </ul> <p>Vediamo un esempio di codice che implementa un semplice client e un semplice server basati su TCP. Il client potr\u00e0 inviare qualsiasi messaggio vuole, mentre il server risponder\u00e0 comunque ok. Se il client invia la stringa close il server saluta con bye e chiude la connessione.</p> Simple Python TCP server<pre><code>import socket\n\nHOST = \"127.0.0.1\"  # Standard loopback interface address (localhost)\nPORT = 65432        # Port to listen on (non-privileged ports are &gt; 1023)\n\ntcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntcp_socket.bind( (HOST, PORT) )\ntcp_socket.listen()\n\nprint(f\"listening on socket ({HOST}:{PORT})...\")\n\nconn, addr = tcp_socket.accept()\n\nif conn:\n    print(f\"Connected by {addr}\")\n\n    while True:\n        data = conn.recv(1024)\n        message = data.decode()\n        print(\"Received:\", message)\n        if message == \"close\":\n            conn.sendall( \"bye\".encode() )\n            break\n        conn.sendall( \"OK\".encode() )\n\nconn.close()\n</code></pre> <p>Qui sotto invece trovate il codice che implementa il client TCP.</p> Simple Python TCP client<pre><code>import socket\n\nHOST = \"127.0.0.1\"  # The server's hostname or IP address\nPORT = 65432  # The port used by the server\n\ntcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ntcp_socket.connect( (HOST, PORT) )\n\nwhile True:\n    message = input(\"Message to send: \")\n\n    tcp_socket.sendall( message.encode() )\n    data = tcp_socket.recv(1024)\n    message = data.decode()\n    print(f\"Received: {data.decode()}\")\n\n    if message == \"bye\":\n        tcp_socket.close()\n        break\n</code></pre>"},{"location":"trasporto/py_socket/#esercizi-su-socket-tcp","title":"Esercizi su socket TCP","text":"<p>Esercizio 3401</p> <p>Implementare un peer ovvero un programma che contiene contemporaneamente client e server TCP. Eseguirne due copie in grado di  colloquiare alternativamente fra loro: il primo manda un msg di testo al secondo, il secondo lo vede e manda una risposta (digitata dall'utente) al primo, il primo legge la risposta e pu\u00f2 rispondere... e cos\u00ec all'infinito (finch\u00e9 non si interrompe il programma).</p> <p>Esercizio 3401 bis</p> <p>Implementare un peer ovvero un programma che contiene contemporaneamente client e server TCP. Eseguirne tre o quattro copie (opportunamente configurate)  in grado di colloquiare fra loro secondo un ordine prestabilito: il primo manda un msg di testo agli altri tre, poi il secondo, poi il terzo, poi il quarto e si ricomincia. Tutti ricevono i messaggi di tutti</p> <p>Esercizio 3401 ter</p> <p>Implementare un server in grado di servire quattro persone che parlano fra di loro. Questo riceve un msg da uno qualsiasi dei client e lo invia agli altri tre. Implementare un client in grado di inviare messaggi al server e di riceverli. Modificare il client in modo da stabilire l'ordine con cui le persone parlano (vedi 3401 bis).</p> <p>Esercizio 3401 quater</p> <p>Implementare un server in grado di servire un numero imprecisato di client. Ogni volta che un client invia un messaggio questi viene aggiunto alla lista dei client a cui inviare i messaggi degli altri. Il client dell'esercizio precedente dovrebbe funzionare bene anche con questo server.</p> <p>Esercizio 3401 quinquies GUI</p> <p>Il server \u00e8 quello dell'esercizio precedente. Il client ha le stesse funzionalit\u00e0 di prima, ma implementa una interfaccia grafica in wxPython.</p> <p>Esercizio 3402</p> <p>Implementare un peer ovvero un programma che contiene contemporaneamente client e server TCP. Entrambi possono scrivere quando vogliono e visualizzano i messaggi che arrivano nell'istante in cui lo fanno.</p> <p>Esercizio 3402 GUI</p> <p>Come l'esercizio precedente, ma fornendo una GUI scritta in wxPython</p> <p>Esercizio 3403</p> <p>Coppia di programmi che permettono di inviare file di testo semplice fra programma e programma. Individuare il file (ad esempio con l'ausilio della libreria pathlib) e inviate la stringa [NOME_FILE + \"\\n\\n\" + CONTENUTO_FILE ]. Il client \u00e8 in grado di salvare nella stessa cartella dello script il file con il nome inviato.</p> <p>Esercizio 3403 GUI</p> <p>Come l'esercizio precedente, ma fornendo una GUI scritta in wxPython.  Eventualmente nel programma di ricezione si pu\u00f2 permettere all'utente di selezionare DOVE salvare il file</p> <p> </p>"},{"location":"trasporto/transport/","title":"Suite Internet: Livello di Trasporto","text":"<p>Il livello di trasporto gestisce la conversazione tra mittente e destinatario, nascondendo tutti i dettagli relativi al trasporto delle informazioni lungo la rete.</p> <p>I compiti del livello si possono inizialmente riassumere come nel disegno sottostante: prende i dati dal livello applicazione, li divide in pacchetti, vi aggiunge un'intestazione e li passa al sottostante livello di rete.</p> <p></p> <p>La Suite Internet offre a livello di trasporto due protocolli:</p> <ul> <li>TCP (Transmission Control Protocol) connesso e affidabile</li> <li>UDP (User Datagram Protocol) non connesso e non affidabile</li> </ul> <p></p> <p>A livello di trasporto, i termini connessione e affidabilit\u00e0 significano:</p> <ol> <li> <p>connessione:</p> <p>Un servizio si dice connesso (a livello di trasporto) quando si preoccupa di stabilire una comunicazione  con il destinatario preventiva all'invio reale dei dati.</p> </li> <li> <p>Affidabilit\u00e0:</p> <p>Un servizio si dice affidabile (a livello di trasporto) quando si preoccupa di rinviare al destinatario  ogni pacchetto che non gli \u00e8 arrivato (o che gli \u00e8 arrivato corrotto).</p> </li> </ol> <p>Un servizio di trasporto connesso e affidabile si preoccupa di stabilire una comunicazione preventiva con il destinatario. Se questi \u00e8 disponibile, invia i pacchetti numerandoli alla partenza e riordinandoli all'arrivo; in caso di pacchetti corrotti o mancanti si preoccupa di richiedere al mittente un nuovo invio di dati, assicurando un arrivo completo degli stessi, oppure una dichiarata impossibilit\u00e0 a ricevere i dati.</p> <p>Un servizio di trasporto non connesso e non affidabile inizia subito l'invio dei pacchetti nell'ordine in cui essi sono arrivati dal livello precedente. All'arrivo scarta semplicemente i pacchetti corrotti, senza richiedere alcun reinvio, toglie l'intestazione del livello di trasporto  e passa il dato al livello superiore.</p> <p>Perch\u00e9 due protocolli?</p> <p>TCP \u00e8 connesso e affidabile.</p> <p>Alcune applicazioni, come ad esempio quelle per inviare mail o files, hanno bisogno di essere sicure che i loro dati arrivino tutti a destinazione e possono accettare piccoli rallentamenti nel trasporto.</p> <p>Queste applicazioni scelgono TCP.</p> <p></p> <p>UDP \u00e8 non connesso e non affidabile.</p> <p>Alcune applicazioni, ad esempio quelle di video e audio streaming, gestiscono i dati in maniera che anche con piccoli \"buchi\" o \"errori\" essi siano fruibili; preferiscono \"scartare\" alcune parti del dato pur di proseguire nella trasmissione e non necessitano di un riordinamento.</p> <p>Queste applicazioni scelgono UDP.</p>"},{"location":"trasporto/transport/#sockets-e-porte","title":"Sockets e Porte","text":"<p>Il protocollo di trasporto per suddividere il traffico in entrata e uscita fra le varie applicazioni che ne richiedono utilizza il meccanismo delle porte logiche.</p> <p>Le porte sono il mezzo essenziale che permette ai protocolli di trasporto di gestire flussi multipli di dati attraverso una unica connessione fisica alla rete.</p> <p>Per fare un paragone con la vita reale immaginiamo di spedire una lettera ad un amico. Se il destinatario vivesse in una abitazione indipendente e ne fosse l'unico inquilino, sulla busta sarebbe sufficiente indicare il suo indirizzo.</p> <p>Questa situazione \u00e8 per\u00f2 piuttosto inusuale in quanto, pi\u00f9 probabilmente, egli vivr\u00e0 in un palazzo con altri condomini oppure condivider\u00e0 l'abitazione con altri parenti. Ognuno di questi pu\u00f2 ricevere posta al medesimo indirizzo e quindi per individuare univocamente il destinatario sar\u00e0 necessario specificare anche il suo nome completo. Allo stesso modo indicheremo sulla busta le informazioni riguardanti il mittente per poter ricevere una risposta.</p> <p>Una cosa analoga avviene per le comunicazioni in rete attraverso la suite TCP/IP. Ogni macchina sar\u00e0 individuata sulla rete da un indirizzo IP ma poich\u00e9 molteplici possono essere i servizi offerti dal sistema e molte le connessioni contemporanee, \u00e8 necessario un metodo per separare i singoli flussi di dati ed indirizzarli verso il corretto programma di gestione.</p> <p>A chi non \u00e8 capitato per esempio di navigare e contemporaneamente di scaricare la posta elettronica o usare un programma p2p? Come fa il sistema a riconoscere a chi sono diretti i dati in arrivo?</p> <p>Il problema viene risolto attraverso il meccanismo delle porte logiche, nel confronto con l'esempio precedente, fanno le veci del nome del nome del mittente e del destinatario.</p> <p>Flussi di dati distinti diretti verso la stessa macchina sono caratterizzati da porte diverse.</p> <p>Una connessione tra due dispositivi, a livello di trasporto, viene univocamente identificata dalle coppie:</p> <ol> <li>\"indirizzo IP : porta\" del mittente</li> <li>\"indirizzo IP : porta\" del destinatario</li> </ol> <p>Ognuna delle coppie \"indirizzo IP: porta\" rappresenta i dati identificativi di un socket, un oggetto software creato dal livello di trasporto per identificare un dispositivo di rete.</p> <p>Per identificare una connessione abbiamo dunque bisogno di 2 socket (per individuare il punto di partenza e il punto di arrivo) allo stesso modo in cui tramite due punti nel piano identifichiamo un segmento.</p> <p>I protocolli del livello di trasporto utilizzano un identificatore a 16 bit (numeri da 0 a 65535), quindi questo rende possibili (teoricamente) fino a 65536 socket contemporaneamente attivi per ogni porta fisica di ogni dispositivo.</p> <p>In linea di principio i numeri di porta per identificare un socket potrebbero essere scelti arbitrariamente durante la connessione ma, come vedremo, la cosa si rivelerebbe decisamente poco pratica.</p> <p>Ogni comunicazione sulla rete presume che inizialmente, in una dei due dispositivi coinvolti, ci sia un software \"in ascolto\", in attesa di un contatto dall'esterno: un server.</p> <p>Ad un certo punto un software in esecuzione sul secondo dispositivo tenta di connettersi al primo: il client.</p> <p>Se un dispositivo collegato ad un rete desidera comunicare con un altro sistema deve necessariamente sapere l'indirizzo completo della macchina remota. In questo caso quindi il client deve essere a conoscenza sia dell'IP sia della porta su cui il server si aspetta di ricevere i dati relativi al servizio di interesse.</p> <p>Se il server scegliesse la porta in modo casuale nessuno saprebbe come raggiungerlo.</p> <p>Per questo motivo nasce l'esigenza di standardizzare e rendere pubblici i numeri di porta relativi ai pi\u00f9 comuni servizi disponibili (server) su internet e sulle reti in genere.</p> <p>In questo modo un client che volesse accedere ad un qualsiasi server HTTP saprebbe a priori di doversi collegare alla porta TCP numero 80. Un server di posta SMTP sar\u00e0 sempre raggiungibile sulla sua porta TCP 25 cos\u00ec come un server FTP user\u00e0 la TCP 21 e un DNS la porta UDP 53.</p> <p>Contrariamente al caso precedente il client non ha mai l'esigenza di rendere pubblico il suo indirizzo completo prima della connessione perch\u00e9 questo verr\u00e0 automaticamente comunicato al server nel momento in cui verr\u00e0 contattato.</p> <p>In questo caso quindi il numero di porta del client pu\u00f2 essere scelto arbitrariamente dal sistema tra quelli al momento disponibili.</p> <p>L'Internet Assigned Numbers Authority (IANA) \u00e8 l'ente che ha tra i suoi scopi la standardizzazione delle porte e l'aggiornamento costante di un documento, chiamato ports-number, contenente l'elenco dei servizi registrati e delle relative porte utilizzate. A questo scopo, nel suddetto documento, lo spazio delle 65536 porte UDP e TCP \u00e8 stato suddiviso in tre parti:</p> <ol> <li> <p>Porte Note (da 0 a 1023)</p> <p>L'accesso a queste porte \u00e8 riservato a servizi con privilegi amministrativi. Tipicamente ogni protocollo del livello superiore ha la sua porta pi\u00f9 conosciuta (quella del server) in questo gruppo.</p> </li> <li> <p>Porte Registrate (da 1024 a 49151)</p> <p>L'accesso a queste porte \u00e8 libero per l'utilizzo da parte di chiunque.  Di solito, ogni protocollo del livello superiore ha una porta per il server in questo gruppo, in modo che chiunque possa eseguire un server senza privilegi amministrativi, ad esempio per motivi di test, di sviluppo, etc.</p> <p>Vi sono inoltre registrati tutti quei servizi che non necessitano di privilegi amministrativi, come i servizi p2p o i servizi di condivisione utente per file e stampanti.</p> <p>Ultima tipologia di porte registrate in questa area sono quei client di cui, per necessit\u00e0 del protocollo, \u00e8 necessario conoscere a priori la porta utilizzata.</p> </li> <li> <p>Porte Dinamiche (da 49152 a 65535)</p> <p>L'accesso a queste porte \u00e8 libero per l'utilizzo da parte di chiunque e nessuna di esse pu\u00f2 essere registrata per uno scopo particolare.  In questo gruppo tipicamente i client scelgono la loro porta da utilizzare per il socket necessario alla connessione. Nell'improbabile caso della saturazione di questo gruppo sono comunque utilizzabili anche le porte del secondo gruppo rimaste libere.</p> </li> </ol> <p>L'elenco completo delle porte assegnate pu\u00f2 essere reperito nel documento pubblicato da IANA al seguente indirizzo web (http://www.iana.org/assignments/port-numbers).</p> <p>Nella tabella seguente elenco le porte utilizzate dai protocolli pi\u00f9 comuni.</p> <p>Ovviamente dovrete impararle tutte!</p> <p></p>"},{"location":"trasporto/transport/#il-protocollo-tcp","title":"Il protocollo TCP","text":"<p>Il protocollo TCP \u00e8 senza dubbio il principale protocollo che implementa il livello di trasporto nella suite Internet. \u00c8 stato definito per la prima volta nel 1981 tramite il documento RFC 793, che ha subito successivamente numerosi aggiornamenti.</p> <p>Esso fornisce un metodo per garantire una consegna sicura e ordinata delle informazioni, utilizzando metodi connessi e affidabili e stabilendo connessioni punto a punto fra mittente e destinatario. Questo implica dunque anche l'impossibilit\u00e0 di supportare broadcasting e multicasting (tecniche di trasmissione \"multipla\" a livello di rete).</p> <p>TCP riceve un flusso di dati da una applicazione e lo divide in TPDU grandi solitamente 1500 byte, ma comunque non pi\u00f9 di 64 Kb e li passa poi al livello di rete, di cui utilizza sempre il protocollo IP.</p> <p>L'intestazione del pacchetto TCP \u00e8 di 20 byte, organizzati nel modo seguente:</p> <p></p> <p>Dove specifichiamo i campi pi\u00f9 importanti:</p> <ul> <li>la porta mittente e destinatario sono le porte logiche TCP del mittente e del destinatario</li> <li>Gli 8 flag (bit) di stato servono per indicare informazioni come i pacchetti SYN, ACK, FIN.</li> <li>Il CRC (cyclic redundancy check) serve a verificare se il pacchetto \u00e8 corrotto oppure no.</li> </ul>"},{"location":"trasporto/transport/#three-way-handshake","title":"Three way handshake","text":"<p>Il protocollo TCP, per stabilire una connessione utilizza il metodo \"three way handshake\", ideato per assicurare al mittente la presenza e la raggiungibilit\u00e0 del destinatario prima di iniziare l'invio vero e proprio dei dati.</p> <p></p> <p>Passo 1</p> <p>Il client invia una richiesta di connessione in un pacchetto denominato SYN, contenente un identificativo A.</p> <p>Passo 2</p> <p>Se il server riceve questa notifica, questi risponde con un pacchetto denominato SYN+ACK.</p> <p>Il SYN \u00e8 il pacchetto di sincronizzazione, contenente un identificativo B; l'ACK \u00e8 la conferma (acknoledgement) del SYN sopraggiunto, contenente l'identificativo A + 1.</p> <p>Passo 3</p> <p>Se il client riceve il pacchetto SYN+ACK dal server, per lui la connessione \u00e8 aperta. Invia inoltre un pacchetto ACK di conferma contenente l'identificativo B + 1.</p> <p>Se il server riceve questa ulteriore informazione apre anch'esso la connessione con il client.</p> <p></p> <p>La chiusura di una connessione avviene in genere anch'essa con il metodo \"three way handshake\". Per concordare una chiusura:</p> <p>una stazione manda un segnale di chiusura e fa partire un timer (passo 1);</p> <p>la seconda quando riceve il segnale invia una conferma e chiude la connessione (passo 2).</p> <p>Se la conferma arriva a destinazione, la prima stazione chiude la connessione,  altrimenti lo fa comunque allo scadere del tempo cronometrato dal timer.</p> <p>Questa differenza di comportamento fra apertura e chiusura si esplicita nell'uso dei pacchetti: SYN e ACK per l'apertura, FYN e ACK per la chiusura.</p> <p>Analogamente, quando la connessione \u00e8 stabilita e dopo ogni pacchetto inviato, le stazioni fanno partire un timer oltre il quale chiudere la connessione se non si riceve o invia nulla nel frattempo. Questa strategia viene messa in atto per evitare di tenere in piedi connessioni \"eterne\" fra stazioni che non trasmettono mai.</p> <p>Per mantenere in piedi le connessioni quindi, il livello deve fare \"qualcosa\", altrimenti il timer descritto chiuder\u00e0 automaticamente la connessione. Se i livelli superiori richiedono una connessione attiva che dura nel tempo anche a fronte di nessun invio di dati (esempio: chat in cui nessuno parla) il livello di trasporto mantiene attiva la connessione inviando ad intervalli regolari dei pacchetti vuoti (dummy), che appunto hanno l'unico scopo di mantenere viva la connessione.</p>"},{"location":"trasporto/transport/#il-protocollo-udp","title":"Il protocollo UDP","text":"<p>Il protocollo UDP \u00e8 uno dei primi protocolli della suite Internet progettati. Il documento RFC 768 che lo definisce \u00e8 stato reso definitivo nel 1980 e, incredibile a dirsi, non \u00e8 stato mai pi\u00f9 ritoccato o rivisto. Pensate inoltre che \u00e8 un documento di sole 2 pagine... come dire... presto e bene!</p> <p>UDP fornisce un metodo per spedire dati senza dover stabilire una connessione con il destinatario (non connesso) e senza dover verificare i dati arrivati ad esso (non affidabile). A dirla tutta non si preoccupa nemmeno di riordinare i pacchetti giunti a destinazione.</p> <p>Risulta quindi un protocollo molto veloce (leggi: pi\u00f9 veloce di TCP, ma molto pi\u00f9 limitato) ed \u00e8 inoltre l'unico protocollo di trasporto abile alle trasmissioni in broadcast e multicast.</p> <p>L'intestazione dei datagrammi UDP ha il seguente formato:</p> <p></p> <p>UDP fornisce soltanto i servizi essenziali del livello di trasporto:</p> <ul> <li>multiplazione delle connessioni, tramite il meccanismo di     assegnazione delle porte;</li> <li>verifica dell'integrit\u00e0 dei dati, tramite il meccanismo CRC</li> </ul> <p>Tutto questo per ridurre al minimo la latenza della connessione e fornire un servizio rapido e leggero ai protocolli superiori.</p> <p>Esempi di protocolli che utilizzano UDP sono:</p> <ul> <li>DNS (nella versione originale, senza sicurezza)</li> <li>DHCP (forzatamente, poich\u00e9 invia i pacchetti in broadcast)</li> <li>Tutti i protocolli di streaming audio/video e VoIP (di solito     trasmessi su 2 canali: uno TCP per i comandi, uno UDP per il flusso     dati)</li> </ul> <p> </p>"}]}